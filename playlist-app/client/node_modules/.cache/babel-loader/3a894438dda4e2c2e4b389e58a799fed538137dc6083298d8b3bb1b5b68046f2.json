{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name2 in all) __defProp(target, name2, {\n    get: all[name2],\n    enumerable: true\n  });\n};\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/modules/invariant.ts\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    if (message === void 0) {\n      throw new Error(\"invariant requires an error message argument\");\n    }\n  }\n  const error = !message ? new Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\") : new Error(message);\n  error.name = \"colorizr\";\n  throw error;\n}\n\n// src/modules/constants.ts\nvar COLOR_KEYS = {\n  hsl: [\"h\", \"s\", \"l\"],\n  oklab: [\"l\", \"a\", \"b\"],\n  oklch: [\"l\", \"c\", \"h\"],\n  rgb: [\"r\", \"g\", \"b\"]\n};\nvar COLOR_MODELS = [\"hsl\", \"oklab\", \"oklch\", \"rgb\"];\nvar DEG2RAD = Math.PI / 180;\nvar LAB_TO_LMS = {\n  l: [0.3963377773761749, 0.2158037573099136],\n  m: [-0.1055613458156586, -0.0638541728258133],\n  s: [-0.0894841775298119, -1.2914855480194092]\n};\nvar LRGB_TO_LMS = {\n  l: [0.4122214708, 0.5363325363, 0.0514459929],\n  m: [0.2119034982, 0.6806995451, 0.1073969566],\n  s: [0.0883024619, 0.2817188376, 0.6299787005]\n};\nvar LSM_TO_LAB = {\n  l: [0.2104542553, 0.793617785, 0.0040720468],\n  a: [1.9779984951, 2.428592205, 0.4505937099],\n  b: [0.0259040371, 0.7827717662, 0.808675766]\n};\nvar LSM_TO_RGB = {\n  r: [4.076741636075958, -3.307711539258063, 0.2309699031821043],\n  g: [-1.2684379732850315, 2.609757349287688, -0.341319376002657],\n  b: [-0.0041960761386756, -0.7034186179359362, 1.7076146940746117]\n};\nvar SRGB_TO_P3 = [[0.8224270476, 0.1775729524, 0], [0.0331008087, 0.9668991913, 0], [0.0170720188, 0.0723477973, 0.9105801839]];\nvar PRECISION = 5;\nvar RAD2DEG = 180 / Math.PI;\nvar MESSAGES = {\n  alpha: \"amount must be a number between 0 and 1\",\n  hueRange: \"hue must be a number between 0 and 360\",\n  input: \"input is required\",\n  inputHex: \"input is required and must be a hex\",\n  inputNumber: \"input is required and must be a number\",\n  inputString: \"input is required and must be a string\",\n  invalid: \"invalid input\",\n  invalidCSS: \"invalid CSS string\",\n  left: \"left is required and must be a string\",\n  lightnessRange: \"lightness must be a number between 0 and 1\",\n  options: \"invalid options\",\n  right: \"right is required and must be a string\",\n  threshold: \"threshold must be a number between 0 and 255\"\n};\n\n// src/modules/css-colors.ts\nvar cssColors = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n};\n\n// src/modules/validators.ts\nfunction hasValidMatches(input) {\n  return Array.isArray(input) && input.length === 6;\n}\nfunction isNamedColor(input) {\n  return isString(input) && Object.keys(cssColors).includes(input.toLowerCase());\n}\nfunction isNumber(input) {\n  return typeof input === \"number\" && !Number.isNaN(input);\n}\nfunction isPlainObject(input) {\n  if (!input) {\n    return false;\n  }\n  const {\n    toString\n  } = Object.prototype;\n  const prototype = Object.getPrototypeOf(input);\n  return toString.call(input) === \"[object Object]\" && (prototype === null || prototype === Object.getPrototypeOf({}));\n}\nfunction isString(input, validate = true) {\n  const isValid = typeof input === \"string\";\n  if (validate) {\n    return isValid && !!input.trim().length;\n  }\n  return isValid;\n}\nfunction isValidColorModel(input) {\n  return isHSL(input) || isRGB(input) || isLAB(input) || isLCH(input);\n}\nfunction isHex(input) {\n  if (!isString(input)) {\n    return false;\n  }\n  return /^#([\\da-f]{3,4}|[\\da-f]{6,8})$/i.test(input);\n}\nfunction isHSL(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"h\") {\n      return value >= 0 && value <= 360;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.hsl.includes(key) && value >= 0 && value <= 100;\n  });\n}\nfunction isLAB(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"l\") {\n      return value >= 0 && value <= 100;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.oklab.includes(key) && value >= -1 && value <= 1;\n  });\n}\nfunction isLCH(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"l\") {\n      return value >= 0 && value <= 100;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.oklch.includes(key) && value >= 0 && value <= (key === \"h\" ? 360 : 1);\n  });\n}\nfunction isRGB(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.rgb.includes(key) && value >= 0 && value <= 255;\n  });\n}\n\n// src/modules/utils.ts\nfunction addAlpha(input, alpha) {\n  invariant(isValidColorModel(input), MESSAGES.invalid);\n  let value = alpha;\n  if (!value) {\n    return input;\n  }\n  if (value > 1) {\n    value /= 100;\n  }\n  if (value === 1) {\n    return input;\n  }\n  return {\n    ...input,\n    alpha: value\n  };\n}\nfunction clamp(value, min = 0, max = 100) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction constrainDegrees(input, amount) {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n  let value = input + amount;\n  if (value > 360) {\n    value %= 360;\n  }\n  if (value < 0) {\n    value += 360;\n  }\n  return Math.abs(value);\n}\nfunction limit(input, model, key) {\n  invariant(isNumber(input), \"Input is not a number\");\n  invariant(COLOR_MODELS.includes(model), `Invalid model${model ? `: ${model}` : \"\"}`);\n  invariant(COLOR_KEYS[model].includes(key), `Invalid key${key ? `: ${key}` : \"\"}`);\n  switch (model) {\n    case \"hsl\":\n      {\n        invariant(COLOR_KEYS.hsl.includes(key), \"Invalid key\");\n        if ([\"s\", \"l\"].includes(key)) {\n          return clamp(input);\n        }\n        return clamp(input, 0, 360);\n      }\n    case \"rgb\":\n      {\n        invariant(COLOR_KEYS.rgb.includes(key), \"Invalid key\");\n        return clamp(input, 0, 255);\n      }\n    /* c8 ignore next 3 */\n    default:\n      {\n        throw new Error(\"Invalid inputs\");\n      }\n  }\n}\nfunction parseInput(input, model) {\n  const keys = COLOR_KEYS[model];\n  const validator = {\n    hsl: isHSL,\n    oklab: isLAB,\n    oklch: isLCH,\n    rgb: isRGB\n  };\n  invariant(isPlainObject(input) || Array.isArray(input), MESSAGES.invalid);\n  const value = Array.isArray(input) ? {\n    [keys[0]]: input[0],\n    [keys[1]]: input[1],\n    [keys[2]]: input[2]\n  } : input;\n  invariant(validator[model](value), `invalid ${model} color`);\n  return value;\n}\nfunction restrictValues(input, precision = PRECISION, forcePrecision = true) {\n  const output = new Map(Object.entries(input));\n  for (const [key, value] of output.entries()) {\n    output.set(key, round(value, precision, forcePrecision));\n  }\n  return Object.fromEntries(output);\n}\nfunction round(input, precision = 2, forcePrecision = true) {\n  if (!isNumber(input) || input === 0) {\n    return 0;\n  }\n  if (forcePrecision) {\n    const factor2 = 10 ** precision;\n    return Math.round(input * factor2) / factor2;\n  }\n  const absInput = Math.abs(input);\n  let digits = Math.abs(Math.ceil(Math.log(absInput) / Math.LN10));\n  if (digits === 0) {\n    digits = 2;\n  } else if (digits > precision) {\n    digits = precision;\n  }\n  let exponent = precision - (digits < 0 ? 0 : digits);\n  if (exponent <= 1 && precision > 1) {\n    exponent = 2;\n  } else if (exponent > precision || exponent === 0) {\n    exponent = precision;\n  }\n  const factor = 10 ** exponent;\n  return Math.round(input * factor) / factor;\n}\n\n// src/modules/hex-utils.ts\nfunction addAlphaToHex(input, alpha) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  invariant(isNumber(alpha), MESSAGES.inputNumber);\n  if (alpha >= 1) {\n    return removeAlphaFromHex(input);\n  }\n  return `${removeAlphaFromHex(input)}${convertAlphaToHex(alpha)}`;\n}\nfunction convertAlphaToHex(input) {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n  let alpha = input;\n  if (input > 1) {\n    alpha /= 100;\n  }\n  return Math.round(alpha * 255).toString(16).padStart(2, \"0\");\n}\nfunction extractAlphaFromHex(input) {\n  invariant(isHex(input), MESSAGES.inputString);\n  const alpha = input.substring(7, 9);\n  if (!alpha) {\n    return 1;\n  }\n  return round(parseInt(alpha, 16) / 255);\n}\nfunction hexadecimalToNumber(input) {\n  return round(parseInt(input, 16));\n}\nfunction removeAlphaFromHex(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  if (input.length === 5) {\n    return input.substring(0, 4);\n  }\n  return input.substring(0, 7);\n}\n\n// src/converters/index.ts\nvar converters_exports = {};\n__export(converters_exports, {\n  hex2hsl: () => hex2hsl,\n  hex2oklab: () => hex2oklab,\n  hex2oklch: () => hex2oklch,\n  hex2rgb: () => hex2rgb,\n  hsl2hex: () => hsl2hex,\n  hsl2oklab: () => hsl2oklab,\n  hsl2oklch: () => hsl2oklch,\n  hsl2rgb: () => hsl2rgb,\n  oklab2hex: () => oklab2hex,\n  oklab2hsl: () => oklab2hsl,\n  oklab2oklch: () => oklab2oklch,\n  oklab2rgb: () => oklab2rgb,\n  oklch2hex: () => oklch2hex,\n  oklch2hsl: () => oklch2hsl,\n  oklch2oklab: () => oklch2oklab,\n  oklch2rgb: () => oklch2rgb,\n  rgb2hex: () => rgb2hex,\n  rgb2hsl: () => rgb2hsl,\n  rgb2oklab: () => rgb2oklab,\n  rgb2oklch: () => rgb2oklch\n});\n\n// src/format-hex.ts\nfunction formatHex(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  let color = input.replace(\"#\", \"\");\n  if (color.length === 3 || color.length === 4) {\n    const values = [...color];\n    color = \"\";\n    values.forEach(d => {\n      color += `${d}${d}`;\n    });\n  }\n  const hex = `#${color}`;\n  invariant(isHex(hex), \"invalid hex\");\n  return hex;\n}\n\n// src/converters/hex2rgb.ts\nfunction hex2rgb(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  const hex = formatHex(input).slice(1);\n  return {\n    r: parseInt(hex.charAt(0) + hex.charAt(1), 16),\n    g: parseInt(hex.charAt(2) + hex.charAt(3), 16),\n    b: parseInt(hex.charAt(4) + hex.charAt(5), 16)\n  };\n}\n\n// src/converters/rgb2hsl.ts\nfunction rgb2hsl(input) {\n  const value = parseInput(input, \"rgb\");\n  const rLimit = limit(value.r, \"rgb\", \"r\") / 255;\n  const gLimit = limit(value.g, \"rgb\", \"g\") / 255;\n  const bLimit = limit(value.b, \"rgb\", \"b\") / 255;\n  const min = Math.min(rLimit, gLimit, bLimit);\n  const max = Math.max(rLimit, gLimit, bLimit);\n  const delta = max - min;\n  let h = 0;\n  let s;\n  const l = (max + min) / 2;\n  let rate;\n  switch (max) {\n    case rLimit:\n      rate = !delta ? 0 : (gLimit - bLimit) / delta;\n      h = 60 * rate;\n      break;\n    case gLimit:\n      rate = (bLimit - rLimit) / delta;\n      h = 60 * rate + 120;\n      break;\n    case bLimit:\n      rate = (rLimit - gLimit) / delta;\n      h = 60 * rate + 240;\n      break;\n    /* c8 ignore next 2 */\n    default:\n      break;\n  }\n  if (h < 0) {\n    h = 360 + h;\n  }\n  if (min === max) {\n    s = 0;\n  } else {\n    s = l < 0.5 ? delta / (2 * l) : delta / (2 - 2 * l);\n  }\n  return {\n    h: Math.abs(+(h % 360).toFixed(2)),\n    s: +(s * 100).toFixed(2),\n    l: +(l * 100).toFixed(2)\n  };\n}\n\n// src/converters/hex2hsl.ts\nfunction hex2hsl(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2hsl(hex2rgb(input));\n}\n\n// src/converters/rgb2oklab.ts\nvar {\n  cbrt,\n  sign\n} = Math;\nfunction rgb2lrgb(input) {\n  const abs2 = Math.abs(input);\n  if (abs2 < 0.04045) {\n    return input / 12.92;\n  }\n  return (sign(input) || 1) * ((abs2 + 0.055) / 1.055) ** 2.4;\n}\nfunction rgb2oklab(input, precision = PRECISION) {\n  const value = parseInput(input, \"rgb\");\n  const [lr, lg, lb] = [rgb2lrgb(value.r / 255), rgb2lrgb(value.g / 255), rgb2lrgb(value.b / 255)];\n  const l = cbrt(LRGB_TO_LMS.l[0] * lr + LRGB_TO_LMS.l[1] * lg + LRGB_TO_LMS.l[2] * lb);\n  const m = cbrt(LRGB_TO_LMS.m[0] * lr + LRGB_TO_LMS.m[1] * lg + LRGB_TO_LMS.m[2] * lb);\n  const s = cbrt(LRGB_TO_LMS.s[0] * lr + LRGB_TO_LMS.s[1] * lg + LRGB_TO_LMS.s[2] * lb);\n  const lab = {\n    l: LSM_TO_LAB.l[0] * l + LSM_TO_LAB.l[1] * m - LSM_TO_LAB.l[2] * s,\n    a: LSM_TO_LAB.a[0] * l - LSM_TO_LAB.a[1] * m + LSM_TO_LAB.a[2] * s,\n    b: LSM_TO_LAB.b[0] * l + LSM_TO_LAB.b[1] * m - LSM_TO_LAB.b[2] * s\n  };\n  return restrictValues(lab, precision);\n}\n\n// src/converters/hex2oklab.ts\nfunction hex2oklab(input, precision) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2oklab(hex2rgb(input), precision);\n}\n\n// src/converters/oklab2oklch.ts\nvar {\n  atan2,\n  sqrt\n} = Math;\nfunction oklab2oklch(input, precision) {\n  const {\n    l,\n    a,\n    b\n  } = restrictValues(parseInput(input, \"oklab\"));\n  const c = sqrt(a ** 2 + b ** 2);\n  let h = (atan2(b, a) * RAD2DEG + 360) % 360;\n  if (round(c * 1e4) === 0) {\n    h = 0;\n  }\n  return restrictValues({\n    l,\n    c,\n    h\n  }, precision);\n}\n\n// src/converters/rgb2oklch.ts\nfunction rgb2oklch(input, precision) {\n  const value = parseInput(input, \"rgb\");\n  return oklab2oklch(rgb2oklab(value, precision), precision);\n}\n\n// src/converters/hex2oklch.ts\nfunction hex2oklch(input, precision) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2oklch(hex2rgb(input), precision);\n}\n\n// src/modules/hue2rgb.ts\nfunction hue2rgb(point, chroma2, h) {\n  invariant(isNumber(point) && isNumber(chroma2) && isNumber(h), \"point, chroma and h are required\");\n  let hue = h;\n  if (hue < 0) {\n    hue += 1;\n  }\n  if (hue > 1) {\n    hue -= 1;\n  }\n  if (hue < 1 / 6) {\n    return round(point + (chroma2 - point) * 6 * hue, 4);\n  }\n  if (hue < 1 / 2) {\n    return round(chroma2, 4);\n  }\n  if (hue < 2 / 3) {\n    return round(point + (chroma2 - point) * (2 / 3 - hue) * 6, 4);\n  }\n  return round(point, 4);\n}\n\n// src/converters/hsl2rgb.ts\nfunction hsl2rgb(input) {\n  const value = parseInput(input, \"hsl\");\n  const h = round(value.h) / 360;\n  const s = round(value.s) / 100;\n  const l = round(value.l) / 100;\n  let r;\n  let g;\n  let b;\n  let point;\n  let chroma2;\n  if (s === 0) {\n    r = l;\n    g = l;\n    b = l;\n  } else {\n    chroma2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    point = 2 * l - chroma2;\n    r = hue2rgb(point, chroma2, h + 1 / 3);\n    g = hue2rgb(point, chroma2, h);\n    b = hue2rgb(point, chroma2, h - 1 / 3);\n  }\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n}\n\n// src/converters/rgb2hex.ts\nfunction rgb2hex(input) {\n  const rgb = parseInput(input, \"rgb\");\n  return `#${Object.values(rgb).map(d => `0${Math.floor(d).toString(16)}`.slice(-2)).join(\"\")}`;\n}\n\n// src/converters/hsl2hex.ts\nfunction hsl2hex(input) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2hex(hsl2rgb(value));\n}\n\n// src/converters/hsl2oklab.ts\nfunction hsl2oklab(input, precision) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2oklab(hsl2rgb(value), precision);\n}\n\n// src/converters/hsl2oklch.ts\nfunction hsl2oklch(input, precision) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2oklch(hsl2rgb(value), precision);\n}\n\n// src/converters/oklab2rgb.ts\nvar {\n  abs\n} = Math;\nfunction lrgb2rgb(input) {\n  const absoluteNumber = abs(input);\n  const sign2 = input < 0 ? -1 : 1;\n  if (absoluteNumber > 31308e-7) {\n    return sign2 * (absoluteNumber ** (1 / 2.4) * 1.055 - 0.055);\n  }\n  return input * 12.92;\n}\nfunction oklab2rgb(input, precision = 0) {\n  const {\n    l: L,\n    a: A,\n    b: B\n  } = parseInput(input, \"oklab\");\n  const l = (L + LAB_TO_LMS.l[0] * A + LAB_TO_LMS.l[1] * B) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * A + LAB_TO_LMS.m[1] * B) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * A + LAB_TO_LMS.s[1] * B) ** 3;\n  const r = 255 * lrgb2rgb(LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s);\n  const g = 255 * lrgb2rgb(LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s);\n  const b = 255 * lrgb2rgb(LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s);\n  return {\n    r: clamp(round(r, precision), 0, 255),\n    g: clamp(round(g, precision), 0, 255),\n    b: clamp(round(b, precision), 0, 255)\n  };\n}\n\n// src/converters/oklab2hex.ts\nfunction oklab2hex(input) {\n  const value = parseInput(input, \"oklab\");\n  return rgb2hex(oklab2rgb(value));\n}\n\n// src/converters/oklab2hsl.ts\nfunction oklab2hsl(input) {\n  const value = parseInput(input, \"oklab\");\n  return rgb2hsl(oklab2rgb(value));\n}\n\n// src/converters/oklch2oklab.ts\nvar {\n  sin,\n  cos\n} = Math;\nfunction oklch2oklab(input, precision) {\n  let {\n    l,\n    c,\n    h\n  } = parseInput(input, \"oklch\");\n  if (Number.isNaN(h) || h < 0) {\n    h = 0;\n  }\n  return restrictValues({\n    l,\n    a: c * cos(h * DEG2RAD),\n    b: c * sin(h * DEG2RAD)\n  }, precision);\n}\n\n// src/converters/oklch2rgb.ts\nfunction oklch2rgb(input, precision = 0) {\n  const value = parseInput(input, \"oklch\");\n  return oklab2rgb(oklch2oklab(value), precision);\n}\n\n// src/converters/oklch2hex.ts\nfunction oklch2hex(input) {\n  const value = parseInput(input, \"oklch\");\n  return rgb2hex(oklch2rgb(value));\n}\n\n// src/converters/oklch2hsl.ts\nfunction oklch2hsl(input) {\n  const value = parseInput(input, \"oklch\");\n  return rgb2hsl(oklch2rgb(value));\n}\n\n// src/extract-color-parts.ts\nfunction extractColorParts(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  if (isHex(input)) {\n    const keys2 = COLOR_KEYS.rgb;\n    const {\n      r,\n      g,\n      b\n    } = hex2rgb(input);\n    const alpha2 = extractAlphaFromHex(input);\n    return {\n      model: \"rgb\",\n      [keys2[0]]: r,\n      [keys2[1]]: g,\n      [keys2[2]]: b,\n      alpha: alpha2 < 1 ? alpha2 : void 0\n    };\n  }\n  const colorRegex = /(?:(rgb|hsl|oklab|oklch)a?\\s*\\(\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)(?:\\s*[ ,/]\\s*([\\d%.-]+))?\\s*\\))/i;\n  const matches = colorRegex.exec(input);\n  invariant(hasValidMatches(matches), MESSAGES.invalidCSS);\n  const model = matches[1];\n  const keys = COLOR_KEYS[model];\n  let alpha = matches[5] ? parseFloat(matches[5]) : 1;\n  if (alpha > 1) {\n    alpha /= 100;\n  }\n  return {\n    model,\n    [keys[0]]: parseFloat(matches[2]),\n    [keys[1]]: parseFloat(matches[3]),\n    [keys[2]]: parseFloat(matches[4]),\n    alpha: alpha < 1 ? alpha : void 0\n  };\n}\n\n// src/parse-css.ts\nfunction parseCSS(input, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  let result;\n  const value = isNamedColor(input) ? cssColors[input.toLowerCase()] : input;\n  const output = format ?? (isHex(value) ? \"hex\" : extractColorParts(value).model);\n  const colorParams = params => Object.values(params);\n  if (isHex(value)) {\n    const alpha = extractAlphaFromHex(value);\n    switch (output) {\n      case \"hsl\":\n        {\n          result = addAlpha(hex2hsl(value), alpha);\n          break;\n        }\n      case \"oklab\":\n        {\n          result = addAlpha(hex2oklab(value), alpha);\n          break;\n        }\n      case \"oklch\":\n        {\n          result = addAlpha(hex2oklch(value), alpha);\n          break;\n        }\n      case \"rgb\":\n        {\n          result = addAlpha(hex2rgb(value), alpha);\n          break;\n        }\n      default:\n        {\n          result = `${removeAlphaFromHex(value)}${alpha !== 1 ? convertAlphaToHex(alpha) : \"\"}`;\n          break;\n        }\n    }\n    return result;\n  }\n  switch (output) {\n    case \"hsl\":\n      {\n        const {\n          alpha,\n          model,\n          ...color\n        } = extractColorParts(value);\n        if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n          color.l = round(color.l / 100, PRECISION);\n        }\n        result = addAlpha(model === \"hsl\" ? color : converters_exports[`${model}2hsl`](colorParams(color)), alpha);\n        break;\n      }\n    case \"oklab\":\n      {\n        const {\n          alpha,\n          model,\n          ...color\n        } = extractColorParts(value);\n        if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n          color.l = round(color.l / 100, PRECISION);\n        }\n        result = addAlpha(model === \"oklab\" ? color : converters_exports[`${model}2oklab`](colorParams(color)), alpha);\n        break;\n      }\n    case \"oklch\":\n      {\n        const {\n          alpha,\n          model,\n          ...color\n        } = extractColorParts(value);\n        if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n          color.l = round(color.l / 100, PRECISION);\n        }\n        result = addAlpha(model === \"oklch\" ? color : converters_exports[`${model}2oklch`](colorParams(color)), alpha);\n        break;\n      }\n    case \"rgb\":\n      {\n        const {\n          alpha,\n          model,\n          ...color\n        } = extractColorParts(value);\n        if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n          color.l /= 100;\n        }\n        result = addAlpha(model === \"rgb\" ? color : converters_exports[`${model}2rgb`](colorParams(color)), alpha);\n        break;\n      }\n    case \"hex\":\n    default:\n      {\n        const {\n          alpha,\n          model,\n          ...color\n        } = extractColorParts(value);\n        let alphaPrefix = \"\";\n        if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n          color.l = round(color.l / 100, PRECISION);\n        }\n        if (alpha) {\n          alphaPrefix = convertAlphaToHex(alpha);\n        }\n        result = `${converters_exports[`${model}2hex`](colorParams(color))}${alphaPrefix}`;\n        break;\n      }\n  }\n  return result;\n}\n\n// src/modules/parse-color.ts\nfunction parseColor(color) {\n  invariant(!!color, MESSAGES.input);\n  const output = {};\n  if (isString(color)) {\n    const {\n      alpha = 1\n    } = extractColorParts(color);\n    const type = isHex(color) ? \"hex\" : extractColorParts(color).model;\n    output.hex = addAlphaToHex(parseCSS(color, \"hex\"), alpha);\n    output.hsl = addAlpha(parseCSS(color, \"hsl\"), alpha);\n    output.oklab = addAlpha(parseCSS(color, \"oklab\"), alpha);\n    output.oklch = addAlpha(parseCSS(color, \"oklch\"), alpha);\n    output.rgb = addAlpha(parseCSS(color, \"rgb\"), alpha);\n    output.alpha = alpha;\n    output.type = type;\n  } else if (isPlainObject(color)) {\n    const {\n      alpha = 1\n    } = color;\n    if (isHSL(color)) {\n      output.hsl = {\n        h: limit(color.h, \"hsl\", \"h\"),\n        s: limit(color.s, \"hsl\", \"s\"),\n        l: limit(color.l, \"hsl\", \"l\")\n      };\n      output.rgb = hsl2rgb(output.hsl);\n      output.oklab = hsl2oklab(output.hsl);\n      output.oklch = hsl2oklch(output.hsl);\n      output.type = \"hsl\";\n    } else if (isLAB(color)) {\n      output.hsl = oklab2hsl(color);\n      output.oklab = color;\n      output.oklch = oklab2oklch(color);\n      output.rgb = oklab2rgb(color);\n      output.type = \"oklab\";\n    } else if (isLCH(color)) {\n      output.hsl = oklch2hsl(color);\n      output.oklab = oklch2oklab(color);\n      output.oklch = color;\n      output.rgb = oklch2rgb(color);\n      output.type = \"oklch\";\n    } else if (isRGB(color)) {\n      output.rgb = {\n        r: limit(color.r, \"rgb\", \"r\"),\n        g: limit(color.g, \"rgb\", \"g\"),\n        b: limit(color.b, \"rgb\", \"b\")\n      };\n      output.hsl = rgb2hsl(output.rgb);\n      output.oklab = rgb2oklab(output.rgb);\n      output.oklch = rgb2oklch(output.rgb);\n      output.type = \"rgb\";\n    } else {\n      throw new Error(\"invalid color\");\n    }\n    output.hex = addAlphaToHex(hsl2hex(output.hsl), alpha);\n    output.hsl = addAlpha(output.hsl, alpha);\n    output.oklab = addAlpha(output.oklab, alpha);\n    output.oklch = addAlpha(output.oklch, alpha);\n    output.rgb = addAlpha(output.rgb, alpha);\n    output.alpha = alpha;\n  } else {\n    throw new Error(MESSAGES.input);\n  }\n  return output;\n}\n\n// src/brightness-difference.ts\nfunction brightnessDifference(left, right, precision = PRECISION) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const RGBLeft = parseCSS(left, \"rgb\");\n  const RGBRight = parseCSS(right, \"rgb\");\n  const brightnessLeft = (RGBLeft.r * 299 + RGBLeft.g * 587 + RGBLeft.b * 114) / 1e3;\n  const brightnessRight = (RGBRight.r * 299 + RGBRight.g * 587 + RGBRight.b * 114) / 1e3;\n  return round(Math.abs(brightnessRight - brightnessLeft), precision);\n}\n\n// src/chroma.ts\nfunction chroma(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const {\n    r,\n    g,\n    b\n  } = parseCSS(input, \"rgb\");\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  return round((max - min) / 255, 4);\n}\n\n// src/color-difference.ts\nfunction colorDifference(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const RGBLeft = parseCSS(left, \"rgb\");\n  const RGBRight = parseCSS(right, \"rgb\");\n  return Math.max(RGBLeft.r, RGBRight.r) - Math.min(RGBLeft.r, RGBRight.r) + (Math.max(RGBLeft.g, RGBRight.g) - Math.min(RGBLeft.g, RGBRight.g)) + (Math.max(RGBLeft.b, RGBRight.b) - Math.min(RGBLeft.b, RGBRight.b));\n}\n\n// src/luminance.ts\nfunction luminance(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const {\n    r,\n    g,\n    b\n  } = parseCSS(input, \"rgb\");\n  const rgb = [r / 255, g / 255, b / 255];\n  for (let index = 0; index < rgb.length; index++) {\n    if (rgb[index] <= 0.03928) {\n      rgb[index] /= 12.92;\n    } else {\n      rgb[index] = ((rgb[index] + 0.055) / 1.055) ** 2.4;\n    }\n  }\n  return round(0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2], 4);\n}\n\n// src/contrast.ts\nfunction contrast(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const LuminanceLeft = luminance(left);\n  const LuminanceRight = luminance(right);\n  return round(LuminanceLeft >= LuminanceRight ? (LuminanceLeft + 0.05) / (LuminanceRight + 0.05) : (LuminanceRight + 0.05) / (LuminanceLeft + 0.05));\n}\n\n// src/compare.ts\nfunction compare(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const colorThreshold = 500;\n  const brightnessThreshold = 125;\n  const colorDifference2 = colorDifference(left, right);\n  const contrast2 = contrast(left, right);\n  const brightnessDifference2 = brightnessDifference(left, right);\n  const isBright = brightnessDifference2 >= brightnessThreshold;\n  const hasEnoughDifference = colorDifference2 >= colorThreshold;\n  let compliant = 0;\n  if (isBright && hasEnoughDifference) {\n    compliant = 2;\n  } else if (isBright || hasEnoughDifference) {\n    compliant = 1;\n  }\n  return {\n    brightnessDifference: brightnessDifference2,\n    colorDifference: colorDifference2,\n    compliant,\n    contrast: contrast2,\n    largeAA: contrast2 >= 3,\n    largeAAA: contrast2 >= 4.5,\n    normalAA: contrast2 >= 4.5,\n    normalAAA: contrast2 >= 7\n  };\n}\n\n// src/format-css.ts\nfunction formatCSS(input, options = {}) {\n  invariant(isHex(input) || isValidColorModel(input), MESSAGES.invalid);\n  const {\n    alpha,\n    format = \"hex\",\n    precision = PRECISION,\n    separator: baseSeparator = \" \"\n  } = options;\n  let value;\n  if (isHex(input)) {\n    value = hex2hsl(input);\n  } else if (isHSL(input)) {\n    value = input;\n  } else if (isLAB(input)) {\n    value = oklab2hsl(input);\n  } else if (isLCH(input)) {\n    value = oklch2hsl(input);\n  } else {\n    value = rgb2hsl(input);\n  }\n  const opacity2 = alpha && alpha !== 1 ? `${round(alpha * 100)}%` : null;\n  let params = [];\n  let separator = baseSeparator;\n  switch (format) {\n    case \"hsl\":\n      {\n        const {\n          h,\n          s,\n          l\n        } = value;\n        params = [h, `${s}%`, `${l}%`];\n        break;\n      }\n    case \"oklab\":\n      {\n        separator = \" \";\n        const {\n          l,\n          a,\n          b\n        } = restrictValues(hsl2oklab(value), precision);\n        params = [`${round(l * 100, precision)}%`, a, b];\n        break;\n      }\n    case \"oklch\":\n      {\n        separator = \" \";\n        const {\n          l,\n          c,\n          h\n        } = restrictValues(hsl2oklch(value), precision);\n        params = [`${round(l * 100, precision)}%`, c, h];\n        break;\n      }\n    case \"rgb\":\n      {\n        const {\n          r,\n          g,\n          b\n        } = hsl2rgb(value);\n        params = [r, g, b];\n        break;\n      }\n    default:\n      {\n        const hex = hsl2hex(value);\n        if (alpha && alpha !== 1) {\n          return `${hex}${convertAlphaToHex(alpha)}`;\n        }\n        return hex;\n      }\n  }\n  return `${format}(${params.join(separator)}${opacity2 ? ` / ${opacity2}` : \"\"})`;\n}\n\n// src/modules/updater.ts\nfunction updater(key, operator, format) {\n  return (input, amount) => {\n    invariant(isString(input), MESSAGES.inputString);\n    invariant(isNumber(amount), MESSAGES.alpha);\n    const color = parseCSS(input, \"hsl\");\n    const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n    return formatCSS({\n      ...color,\n      [key]: clamp(color[key] + (operator === \"+\" ? amount : -amount), 0, 100)\n    }, {\n      format: format ?? output\n    });\n  };\n}\n\n// src/darken.ts\nfunction darken(input, amount, format) {\n  return updater(\"l\", \"-\", format)(input, amount);\n}\n\n// src/desaturate.ts\nfunction desaturate(input, amount, format) {\n  return updater(\"s\", \"-\", format)(input, amount);\n}\n\n// src/rotate.ts\nfunction rotate(input, degrees, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(degrees), \"degrees must be a number\");\n  const color = parseCSS(input, \"hsl\");\n  const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  return formatCSS({\n    ...color,\n    h: constrainDegrees(color.h, degrees)\n  }, {\n    format: format ?? output\n  });\n}\n\n// src/invert.ts\nfunction invert(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const format = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const hex = parseCSS(input, \"hex\");\n  return formatCSS(rotate(hex, 180), {\n    format\n  });\n}\n\n// src/lighten.ts\nfunction lighten(input, amount, format) {\n  return updater(\"l\", \"+\", format)(input, amount);\n}\n\n// src/opacify.ts\nfunction opacify(input, alpha, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n  const type = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const rgb = parseCSS(input, \"rgb\");\n  return formatCSS(rgb, {\n    format: format ?? type,\n    alpha\n  });\n}\n\n// src/opacity.ts\nfunction opacity(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  if (isHex(input)) {\n    return extractAlphaFromHex(input);\n  } else if (Object.keys(cssColors).includes(input)) {\n    return 1;\n  }\n  const {\n    alpha\n  } = extractColorParts(input);\n  if (!alpha) {\n    return 1;\n  }\n  return alpha;\n}\n\n// src/saturate.ts\nfunction saturate(input, amount, format) {\n  return updater(\"s\", \"+\", format)(input, amount);\n}\n\n// src/text-color.ts\nfunction textColor(input, options = {}) {\n  const {\n    darkColor = \"#000000\",\n    lightColor = \"#ffffff\",\n    threshold = 128\n  } = options;\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(threshold >= 0 && threshold <= 255, MESSAGES.threshold);\n  const {\n    r,\n    g,\n    b\n  } = hex2rgb(parseCSS(input, \"hex\"));\n  const yiq = (r * 299 + g * 587 + b * 114) / 1e3;\n  return yiq >= threshold ? darkColor : lightColor;\n}\n\n// src/transparentize.ts\nfunction transparentize(input, alpha, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n  invariant(alpha >= -1 && alpha <= 1, MESSAGES.alpha);\n  const oklch = parseCSS(input, \"oklab\");\n  const value = round(clamp(opacity(input) - alpha, 0, 1));\n  return formatCSS(oklch, {\n    format,\n    alpha: value\n  });\n}\n\n// src/colorizr.ts\nvar Colorizr = class {\n  constructor(color, options = {}) {\n    __publicField(this, \"alpha\");\n    __publicField(this, \"hex\");\n    __publicField(this, \"hsl\");\n    __publicField(this, \"oklab\");\n    __publicField(this, \"oklch\");\n    __publicField(this, \"rgb\");\n    __publicField(this, \"type\");\n    invariant(!!color, \"color is required\");\n    const {\n      alpha,\n      hex,\n      hsl,\n      oklab,\n      oklch,\n      rgb,\n      type\n    } = parseColor(color);\n    this.hex = hex;\n    this.hsl = hsl;\n    this.oklab = oklab;\n    this.oklch = oklch;\n    this.rgb = rgb;\n    this.alpha = alpha;\n    this.type = options.format ?? type;\n  }\n  /**\n   * Get css string\n   */\n  get css() {\n    return this.selectedColor;\n  }\n  /**\n   * Get the red value\n   */\n  get red() {\n    return Number(this.rgb.r);\n  }\n  /**\n   * Get the green value\n   */\n  get green() {\n    return Number(this.rgb.g);\n  }\n  /**\n   * Get the blue value\n   */\n  get blue() {\n    return Number(this.rgb.b);\n  }\n  /**\n   * Get the hue value\n   */\n  get hue() {\n    return Number(this.hsl.h);\n  }\n  /**\n   * Get the saturation value\n   */\n  get saturation() {\n    return Number(this.hsl.s);\n  }\n  /**\n   * Get the lightness value\n   */\n  get lightness() {\n    return Number(this.hsl.l);\n  }\n  /**\n   * Get the luminance value\n   */\n  get luminance() {\n    return luminance(this.selectedColor);\n  }\n  /**\n   * Get the chroma value\n   */\n  get chroma() {\n    return chroma(this.selectedColor);\n  }\n  get opacity() {\n    return opacity(this.selectedColor);\n  }\n  /**\n   * Get the contrasted color\n   */\n  get textColor() {\n    return textColor(this.selectedColor);\n  }\n  get selectedColor() {\n    return formatCSS(this[this.type], {\n      format: this.type,\n      alpha: this.alpha\n    });\n  }\n  brightnessDifference(input) {\n    return brightnessDifference(this.selectedColor, input);\n  }\n  colorDifference(input) {\n    return colorDifference(this.selectedColor, input);\n  }\n  /**\n   * Test 2 colors for compliance\n   */\n  compare(input) {\n    return compare(this.selectedColor, input);\n  }\n  contrast(input) {\n    return contrast(this.selectedColor, input);\n  }\n  format(type, precision) {\n    return formatCSS(this.rgb, {\n      alpha: this.alpha,\n      format: type,\n      precision\n    });\n  }\n  /**\n   * Increase lightness\n   */\n  lighten(amount) {\n    return lighten(this.selectedColor, amount);\n  }\n  /**\n   * Decrease lightness\n   */\n  darken(amount) {\n    return darken(this.selectedColor, amount);\n  }\n  /**\n   * Increase saturation\n   */\n  saturate(amount) {\n    return saturate(this.selectedColor, amount);\n  }\n  /**\n   * Decrease saturation\n   */\n  desaturate(amount) {\n    return desaturate(this.selectedColor, amount);\n  }\n  /**\n   * Invert color\n   */\n  invert() {\n    return invert(this.selectedColor);\n  }\n  /**\n   * Add opacity to the color.\n   */\n  opacify(alpha = 0.9) {\n    return opacify(this.selectedColor, alpha, this.type);\n  }\n  /**\n   * Rotate color\n   */\n  rotate(degrees) {\n    return rotate(this.selectedColor, degrees);\n  }\n  /**\n   * Make the color more transparent\n   */\n  transparentize(alpha = 0.1) {\n    return transparentize(this.selectedColor, alpha, this.type);\n  }\n};\n\n// src/convert.ts\nfunction convert(input, format) {\n  const value = parseCSS(input, format);\n  return formatCSS(value, {\n    format\n  });\n}\n\n// src/is-valid-color.ts\nfunction isValidColor(input) {\n  try {\n    parseCSS(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/name.ts\nfunction name(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const hex = parseCSS(input, \"hex\");\n  const [color] = Object.entries(cssColors).find(([, value]) => value === hex) || [];\n  return color ?? hex;\n}\n\n// src/palette.ts\nfunction palette(input, options = {}) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isPlainObject(options), MESSAGES.options);\n  const {\n    format,\n    lightness,\n    saturation,\n    size = 6,\n    type\n  } = options;\n  const hsl = parseCSS(input, \"hsl\");\n  const output = [];\n  const colorFormat = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  switch (type) {\n    case \"monochromatic\":\n      {\n        const step = 80 / size;\n        for (let index = size; index > 0; index--) {\n          output.push(hsl2hex({\n            ...hsl,\n            l: step * index\n          }));\n        }\n        break;\n      }\n    default:\n      {\n        const step = 360 / size;\n        output.push(hsl2hex({\n          ...hsl,\n          l: lightness ?? hsl.l,\n          s: saturation ?? hsl.s\n        }));\n        for (let index = 1; index < size; index++) {\n          const color = rotate(input, hsl.h + step * index, \"hex\");\n          output.push(hsl2hex({\n            ...hex2hsl(color),\n            l: lightness ?? hsl.l,\n            s: saturation ?? hsl.s\n          }));\n        }\n        break;\n      }\n  }\n  return output.map(color => convert(color, format ?? colorFormat));\n}\n\n// src/p3.ts\nfunction multiplyMatrix(matrix, vector) {\n  return [matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2], matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2], matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]];\n}\nfunction isInP3Gamut(color) {\n  const epsilon = 1e-6;\n  return color.every(component => component >= 0 - epsilon && component <= 1 + epsilon);\n}\nfunction oklabToLinearSRGB(L, a, b) {\n  const l = (L + LAB_TO_LMS.l[0] * a + LAB_TO_LMS.l[1] * b) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * a + LAB_TO_LMS.m[1] * b) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * a + LAB_TO_LMS.s[1] * b) ** 3;\n  return [LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s, LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s, LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s];\n}\nfunction oklabToLinearP3(L, a, b) {\n  const srgb = oklabToLinearSRGB(L, a, b);\n  return multiplyMatrix(SRGB_TO_P3, srgb);\n}\nfunction getOkLCHMaxChroma(input, precision = PRECISION) {\n  const {\n    l,\n    h\n  } = isString(input) ? parseCSS(input, \"oklch\") : input;\n  invariant(isNumber(l) && l >= 0 && l <= 1, MESSAGES.lightnessRange);\n  invariant(isNumber(h) && h >= 0 && h <= 360, MESSAGES.hueRange);\n  const epsilon = 1e-6;\n  let low = 0;\n  let high = 0.5;\n  while (high - low > epsilon) {\n    const mid = (low + high) / 2;\n    const {\n      l: L,\n      a,\n      b\n    } = oklch2oklab({\n      l,\n      c: mid,\n      h\n    }, 16);\n    const p3Color = oklabToLinearP3(L, a, b);\n    if (isInP3Gamut(p3Color)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  return round(low, precision);\n}\nfunction getP3Color(input) {\n  const lch = isString(input) ? parseCSS(input, \"oklch\") : input;\n  return `oklch(${lch.l} ${getOkLCHMaxChroma(lch)} ${lch.h})`;\n}\n\n// src/random.ts\nfunction random(type = \"hex\") {\n  const hsl = {\n    h: Math.floor(Math.random() * 360) + 1,\n    s: Math.floor(Math.random() * 90) + 10,\n    l: Math.floor(Math.random() * 80) + 10\n  };\n  return formatCSS(hsl, {\n    format: type\n  });\n}\n\n// src/scheme.ts\nfunction scheme(input, typeOrOptions) {\n  invariant(isString(input), MESSAGES.inputString);\n  const {\n    format,\n    type = \"complementary\"\n  } = isString(typeOrOptions) ? {\n    type: typeOrOptions\n  } : typeOrOptions ?? {};\n  const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const colors = [];\n  switch (type) {\n    case \"analogous\":\n      {\n        colors.push(rotate(input, -30), input, rotate(input, 30));\n        break;\n      }\n    case \"complementary\":\n      {\n        colors.push(input, rotate(input, 180));\n        break;\n      }\n    case \"split\":\n    case \"split-complementary\":\n      {\n        colors.push(input, rotate(input, 150), rotate(input, 210));\n        break;\n      }\n    case \"triadic\":\n      {\n        colors.push(input, rotate(input, 120), rotate(input, 240));\n        break;\n      }\n    case \"tetradic\":\n    case \"rectangle\":\n      {\n        colors.push(input, rotate(input, 60), rotate(input, 180), rotate(input, 240));\n        break;\n      }\n    case \"square\":\n      {\n        colors.push(input, rotate(input, 90), rotate(input, 180), rotate(input, 270));\n        break;\n      }\n    default:\n      {\n        throw new TypeError(\"invalid type\");\n      }\n  }\n  return colors.map(color => convert(color, format ?? output));\n}\n\n// src/swatch.ts\nvar MIN_LIGHTNESS = 21;\nvar MAX_LIGHTNESS = 97;\nfunction shadeColorDynamic(input, lightnessTuningFactor, chromaTuningFactor = 0) {\n  if (lightnessTuningFactor === 0) {\n    return rgb2hex(oklch2rgb({\n      ...input,\n      l: input.l / 100\n    }));\n  }\n  return shadeColor(input, input.l + lightnessTuningFactor, chromaTuningFactor);\n}\nfunction shadeColor(input, lightness, chromaTuningFactor = 0) {\n  const {\n    c,\n    h\n  } = input;\n  return oklch2hex({\n    l: lightness / 100,\n    c: clamp(c + chromaTuningFactor, 0, 0.4),\n    h\n  });\n}\nfunction swatch(input, options = {}) {\n  invariant(isString(input), MESSAGES.inputString);\n  const {\n    format,\n    monochromatic = false,\n    scale = \"dynamic\"\n  } = options;\n  const lch = parseCSS(input, \"oklch\");\n  lch.l = 50;\n  const colorFormat = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const currentLightness = lch.l;\n  const safeMaxLightness = currentLightness >= 88.5 ? 99.5 : MAX_LIGHTNESS;\n  const safeMinLightness = currentLightness <= 33 ? 0 : MIN_LIGHTNESS;\n  const lightBase = (safeMaxLightness - currentLightness) / 5;\n  const darkBase = -1 * (currentLightness - safeMinLightness) / 8;\n  const output = scale === \"linear\" ? {\n    50: shadeColor(lch, 95, monochromatic ? 0 : -375e-5),\n    100: shadeColor(lch, 90, monochromatic ? 0 : -375e-5),\n    200: shadeColor(lch, 80, monochromatic ? 0 : -375e-5),\n    300: shadeColor(lch, 70, monochromatic ? 0 : -375e-5),\n    400: shadeColor(lch, 60, monochromatic ? 0 : -375e-5),\n    500: shadeColor(lch, 50, 0),\n    600: shadeColor(lch, 40, monochromatic ? 0 : 0.025),\n    700: shadeColor(lch, 30, monochromatic ? 0 : 0.05),\n    800: shadeColor(lch, 20, monochromatic ? 0 : 0.075),\n    900: shadeColor(lch, 10, monochromatic ? 0 : 0.1)\n  } : {\n    50: shadeColorDynamic(lch, 5 * lightBase, monochromatic ? 0 : -375e-5),\n    100: shadeColorDynamic(lch, 4 * lightBase, monochromatic ? 0 : -375e-5),\n    200: shadeColorDynamic(lch, 3 * lightBase, monochromatic ? 0 : -375e-5),\n    300: shadeColorDynamic(lch, 2 * lightBase, monochromatic ? 0 : -375e-5),\n    400: shadeColorDynamic(lch, lightBase, monochromatic ? 0 : -375e-5),\n    500: shadeColorDynamic(lch, 0),\n    600: shadeColorDynamic(lch, 1.6 * darkBase, monochromatic ? 0 : 0.025),\n    700: shadeColorDynamic(lch, 1.875 * 2 * darkBase, monochromatic ? 0 : 0.05),\n    800: shadeColorDynamic(lch, 3 * 2 * darkBase, monochromatic ? 0 : 0.075),\n    900: shadeColorDynamic(lch, 4 * 2 * darkBase, monochromatic ? 0 : 0.1)\n  };\n  return Object.entries(output).reduce((acc, [key, value]) => {\n    return {\n      ...acc,\n      [key]: convert(value, format ?? colorFormat)\n    };\n  }, {});\n}\n\n// src/index.ts\nvar index_default = Colorizr;\nexport { addAlphaToHex, brightnessDifference, chroma, colorDifference, compare, contrast, convert, convertAlphaToHex, darken, index_default as default, desaturate, extractAlphaFromHex, extractColorParts, formatCSS, formatHex, getOkLCHMaxChroma, getP3Color, hex2hsl, hex2oklab, hex2oklch, hex2rgb, hexadecimalToNumber, hsl2hex, hsl2oklab, hsl2oklch, hsl2rgb, isHSL, isHex, isLAB, isLCH, isRGB, isValidColor, lighten, luminance, name, oklab2hex, oklab2hsl, oklab2oklch, oklab2rgb, oklch2hex, oklch2hsl, oklch2oklab, oklch2rgb, opacify, opacity, palette, parseCSS, random, removeAlphaFromHex, rgb2hex, rgb2hsl, rgb2oklab, rgb2oklch, rotate, saturate, scheme, swatch, textColor, transparentize };","map":{"version":3,"names":["invariant","condition","message","process","env","NODE_ENV","Error","error","name","COLOR_KEYS","hsl","oklab","oklch","rgb","COLOR_MODELS","DEG2RAD","Math","PI","LAB_TO_LMS","l","m","s","LRGB_TO_LMS","LSM_TO_LAB","a","b","LSM_TO_RGB","r","g","SRGB_TO_P3","PRECISION","RAD2DEG","MESSAGES","alpha","hueRange","input","inputHex","inputNumber","inputString","invalid","invalidCSS","left","lightnessRange","options","right","threshold","cssColors","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","hasValidMatches","Array","isArray","length","isNamedColor","isString","Object","keys","includes","toLowerCase","isNumber","Number","isNaN","isPlainObject","toString","prototype","getPrototypeOf","call","validate","isValid","trim","isValidColorModel","isHSL","isRGB","isLAB","isLCH","isHex","test","entries","every","key","value","addAlpha","clamp","min","max","constrainDegrees","amount","abs","limit","model","parseInput","validator","restrictValues","precision","forcePrecision","output","Map","set","round","fromEntries","factor2","absInput","digits","ceil","log","LN10","exponent","factor","addAlphaToHex","removeAlphaFromHex","convertAlphaToHex","padStart","extractAlphaFromHex","substring","parseInt","hexadecimalToNumber","converters_exports","__export","hex2hsl","hex2oklab","hex2oklch","hex2rgb","hsl2hex","hsl2oklab","hsl2oklch","hsl2rgb","oklab2hex","oklab2hsl","oklab2oklch","oklab2rgb","oklch2hex","oklch2hsl","oklch2oklab","oklch2rgb","rgb2hex","rgb2hsl","rgb2oklab","rgb2oklch","formatHex","color","replace","values","forEach","d","hex","slice","charAt","rLimit","gLimit","bLimit","delta","h","rate","toFixed","cbrt","sign","rgb2lrgb","abs2","lr","lg","lb","lab","atan2","sqrt","c","hue2rgb","point","chroma2","hue","map","floor","join","lrgb2rgb","absoluteNumber","sign2","L","A","B","sin","cos","extractColorParts","keys2","alpha2","colorRegex","matches","exec","parseFloat","parseCSS","format","result","colorParams","params","alphaPrefix","parseColor","type","brightnessDifference","RGBLeft","RGBRight","brightnessLeft","brightnessRight","chroma","colorDifference","luminance","index","contrast","LuminanceLeft","LuminanceRight","compare","colorThreshold","brightnessThreshold","colorDifference2","contrast2","brightnessDifference2","isBright","hasEnoughDifference","compliant","largeAA","largeAAA","normalAA","normalAAA","formatCSS","separator","baseSeparator","opacity2","updater","operator","darken","desaturate","rotate","degrees","invert","lighten","opacify","opacity","saturate","textColor","darkColor","lightColor","yiq","transparentize","Colorizr","constructor","__publicField","css","selectedColor","saturation","lightness","convert","isValidColor","find","palette","size","colorFormat","step","push","multiplyMatrix","matrix","vector","isInP3Gamut","epsilon","component","oklabToLinearSRGB","oklabToLinearP3","srgb","getOkLCHMaxChroma","low","high","mid","p3Color","getP3Color","lch","random","scheme","typeOrOptions","colors","TypeError","MIN_LIGHTNESS","MAX_LIGHTNESS","shadeColorDynamic","lightnessTuningFactor","chromaTuningFactor","shadeColor","swatch","monochromatic","scale","currentLightness","safeMaxLightness","safeMinLightness","lightBase","darkBase","reduce","acc","index_default"],"sources":["/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/invariant.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/constants.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/css-colors.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/validators.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/utils.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/hex-utils.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/index.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/format-hex.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hex2rgb.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/rgb2hsl.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hex2hsl.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/rgb2oklab.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hex2oklab.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklab2oklch.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/rgb2oklch.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hex2oklch.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/hue2rgb.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hsl2rgb.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/rgb2hex.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hsl2hex.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hsl2oklab.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/hsl2oklch.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklab2rgb.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklab2hex.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklab2hsl.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklch2oklab.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklch2rgb.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklch2hex.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/converters/oklch2hsl.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/extract-color-parts.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/parse-css.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/parse-color.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/brightness-difference.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/chroma.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/color-difference.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/luminance.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/contrast.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/compare.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/format-css.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/modules/updater.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/darken.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/desaturate.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/rotate.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/invert.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/lighten.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/opacify.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/opacity.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/saturate.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/text-color.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/transparentize.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/colorizr.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/convert.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/is-valid-color.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/name.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/palette.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/p3.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/random.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/scheme.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/swatch.ts","/Users/sahil/Documents/PycharmProjects/playlist-generator/playlist-app/client/node_modules/colorizr/src/index.ts"],"sourcesContent":["export function invariant(condition: boolean, message: string): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    if (message === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  const error = !message\n    ? new Error(\n        'Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.',\n      )\n    : new Error(message);\n\n  error.name = 'colorizr';\n\n  throw error;\n}\n","import { ColorKeysTuple, ColorModelKey } from '~/types';\n\nexport const COLOR_KEYS: Record<ColorModelKey, ColorKeysTuple> = {\n  hsl: ['h', 's', 'l'],\n  oklab: ['l', 'a', 'b'],\n  oklch: ['l', 'c', 'h'],\n  rgb: ['r', 'g', 'b'],\n};\nexport const COLOR_MODELS: ColorModelKey[] = ['hsl', 'oklab', 'oklch', 'rgb'];\nexport const DEG2RAD = Math.PI / 180;\nexport const LAB_TO_LMS = {\n  l: [0.3963377773761749, 0.2158037573099136],\n  m: [-0.1055613458156586, -0.0638541728258133],\n  s: [-0.0894841775298119, -1.2914855480194092],\n};\nexport const LRGB_TO_LMS = {\n  l: [0.4122214708, 0.5363325363, 0.0514459929],\n  m: [0.2119034982, 0.6806995451, 0.1073969566],\n  s: [0.0883024619, 0.2817188376, 0.6299787005],\n};\nexport const LSM_TO_LAB = {\n  l: [0.2104542553, 0.793617785, 0.0040720468],\n  a: [1.9779984951, 2.428592205, 0.4505937099],\n  b: [0.0259040371, 0.7827717662, 0.808675766],\n};\nexport const LSM_TO_RGB = {\n  r: [4.0767416360759583, -3.3077115392580629, 0.2309699031821043],\n  g: [-1.2684379732850315, 2.6097573492876882, -0.341319376002657],\n  b: [-0.0041960761386756, -0.7034186179359362, 1.7076146940746117],\n};\nexport const SRGB_TO_P3 = [\n  [0.8224270476, 0.1775729524, 0],\n  [0.0331008087, 0.9668991913, 0],\n  [0.0170720188, 0.0723477973, 0.9105801839],\n];\nexport const PRECISION = 5;\nexport const RAD2DEG = 180 / Math.PI;\n\nexport const MESSAGES = {\n  alpha: 'amount must be a number between 0 and 1',\n  hueRange: 'hue must be a number between 0 and 360',\n  input: 'input is required',\n  inputHex: 'input is required and must be a hex',\n  inputNumber: 'input is required and must be a number',\n  inputString: 'input is required and must be a string',\n  invalid: 'invalid input',\n  invalidCSS: 'invalid CSS string',\n  left: 'left is required and must be a string',\n  lightnessRange: 'lightness must be a number between 0 and 1',\n  options: 'invalid options',\n  right: 'right is required and must be a string',\n  threshold: 'threshold must be a number between 0 and 255',\n} as const;\n","/**\n * CSS named colors\n */\n\nexport type CSSColor = keyof typeof cssColors;\n\nexport const cssColors = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkslategrey: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  grey: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  indianred: '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightgrey: '#d3d3d3',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370db',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#db7093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n};\n","import { COLOR_KEYS } from '~/modules/constants';\nimport { cssColors } from '~/modules/css-colors';\n\nimport { ColorModel, HEX, HSL, LAB, LCH, PlainObject, RGB } from '~/types';\n\nexport function hasValidMatches(input: unknown): input is string[] {\n  return Array.isArray(input) && input.length === 6;\n}\n\n/**\n * Check if the input is a CSS named color\n */\nexport function isNamedColor(input: unknown): input is keyof typeof cssColors {\n  return isString(input) && Object.keys(cssColors).includes(input.toLowerCase());\n}\n\n/**\n * Check if the input is a number and not NaN\n */\nexport function isNumber(input: unknown): input is number {\n  return typeof input === 'number' && !Number.isNaN(input);\n}\n\n/**\n * Check if the input is an object\n */\nexport function isPlainObject(input: unknown): input is PlainObject {\n  if (!input) {\n    return false;\n  }\n\n  const { toString } = Object.prototype;\n  const prototype = Object.getPrototypeOf(input);\n\n  return (\n    toString.call(input) === '[object Object]' &&\n    (prototype === null || prototype === Object.getPrototypeOf({}))\n  );\n}\n\n/**\n * Check if the input is a string\n */\nexport function isString(input: unknown, validate = true): input is string {\n  const isValid = typeof input === 'string';\n\n  if (validate) {\n    return isValid && !!input.trim().length;\n  }\n\n  return isValid;\n}\n\nexport function isValidColorModel<T extends ColorModel>(input: T): input is T {\n  return isHSL(input) || isRGB(input) || isLAB(input) || isLCH(input);\n}\n\nexport function isHex(input: any): input is HEX {\n  if (!isString(input)) {\n    return false;\n  }\n\n  return /^#([\\da-f]{3,4}|[\\da-f]{6,8})$/i.test(input);\n}\n\n/**\n * Check if an object contains HSL values\n * The input must be an object with keys 'h', 's', and 'l'\n * with values between 0 and 360 for hue or 0 and 100 for the others.\n */\nexport function isHSL(input: unknown): input is HSL {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(([key, value]) => {\n      if (key === 'h') {\n        return value >= 0 && value <= 360;\n      }\n\n      if (key === 'alpha') {\n        return value >= 0 && value <= 1;\n      }\n\n      return COLOR_KEYS.hsl.includes(key) && value >= 0 && value <= 100;\n    })\n  );\n}\n\n/**\n * Check if an object contains LAB values\n * The input must be an object with keys 'l', 'a', and 'b' with values between -1 and 1.\n */\nexport function isLAB(input: unknown): input is LAB {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(([key, value]) => {\n      if (key === 'l') {\n        return value >= 0 && value <= 100;\n      }\n\n      if (key === 'alpha') {\n        return value >= 0 && value <= 1;\n      }\n\n      return COLOR_KEYS.oklab.includes(key) && value >= -1 && value <= 1;\n    })\n  );\n}\n\n/**\n * Check if an object contains LAB values\n * The input must be an object with keys 'l', 'c', and 'h' with values between 0 and 360.\n */\nexport function isLCH(input: unknown): input is LCH {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(([key, value]) => {\n      if (key === 'l') {\n        return value >= 0 && value <= 100;\n      }\n\n      if (key === 'alpha') {\n        return value >= 0 && value <= 1;\n      }\n\n      return COLOR_KEYS.oklch.includes(key) && value >= 0 && value <= (key === 'h' ? 360 : 1);\n    })\n  );\n}\n\n/**\n * Check if an object contains RGB values.\n * The input must be an object with keys 'r', 'g', and 'b' with values between 0 and 255.\n */\nexport function isRGB(input: unknown): input is RGB {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(([key, value]) => {\n      if (key === 'alpha') {\n        return value >= 0 && value <= 1;\n      }\n\n      return COLOR_KEYS.rgb.includes(key) && value >= 0 && value <= 255;\n    })\n  );\n}\n","import { COLOR_KEYS, COLOR_MODELS, MESSAGES, PRECISION } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport {\n  isHSL,\n  isLAB,\n  isLCH,\n  isNumber,\n  isPlainObject,\n  isRGB,\n  isValidColorModel,\n} from '~/modules/validators';\n\nimport {\n  Alpha,\n  ColorModel,\n  ColorModelKey,\n  ColorModelKeys,\n  ConverterParameters,\n  LAB,\n  LCH,\n  PlainObject,\n} from '~/types';\n\nexport function addAlpha<T extends ColorModel>(input: any, alpha?: Alpha): T {\n  invariant(isValidColorModel(input), MESSAGES.invalid);\n\n  let value = alpha;\n\n  if (!value) {\n    return input;\n  }\n\n  /* c8 ignore next 3 */\n  if (value > 1) {\n    value /= 100;\n  }\n\n  if (value === 1) {\n    return input;\n  }\n\n  return { ...input, alpha: value };\n}\n\n/**\n * Clamp a value between a min and max\n * @param value\n * @param [min=0] - The minimum value\n * @param [max=100] - The maximum value\n */\nexport function clamp(value: number, min = 0, max = 100) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Constrain the degrees between 0 and 360\n */\nexport function constrainDegrees(input: number, amount: number): number {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n\n  let value = input + amount;\n\n  if (value > 360) {\n    value %= 360;\n  }\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return Math.abs(value);\n}\n\n/**\n * Limit values per type.\n */\nexport function limit<TModel extends Extract<ColorModelKey, 'hsl' | 'rgb'>>(\n  input: number,\n  model: TModel,\n  key: ColorModelKeys<TModel>,\n): number {\n  invariant(isNumber(input), 'Input is not a number');\n  invariant(COLOR_MODELS.includes(model), `Invalid model${model ? `: ${model}` : ''}`);\n  invariant(COLOR_KEYS[model].includes(key), `Invalid key${key ? `: ${key}` : ''}`);\n\n  switch (model) {\n    case 'hsl': {\n      invariant(COLOR_KEYS.hsl.includes(key), 'Invalid key');\n\n      if (['s', 'l'].includes(key)) {\n        return clamp(input);\n      }\n\n      return clamp(input, 0, 360);\n    }\n    case 'rgb': {\n      invariant(COLOR_KEYS.rgb.includes(key), 'Invalid key');\n\n      return clamp(input, 0, 255);\n    }\n    /* c8 ignore next 3 */\n    default: {\n      throw new Error('Invalid inputs');\n    }\n  }\n}\n\n/**\n * Parse the input parameters\n */\nexport function parseInput<T extends ColorModel>(\n  input: ConverterParameters<T>,\n  model: ColorModelKey,\n): T {\n  const keys = COLOR_KEYS[model];\n  const validator = {\n    hsl: isHSL,\n    oklab: isLAB,\n    oklch: isLCH,\n    rgb: isRGB,\n  };\n\n  invariant(isPlainObject(input) || Array.isArray(input), MESSAGES.invalid);\n\n  const value = Array.isArray(input)\n    ? ({ [keys[0]]: input[0], [keys[1]]: input[1], [keys[2]]: input[2] } as unknown as T)\n    : input;\n\n  invariant(validator[model](value), `invalid ${model} color`);\n\n  return value;\n}\n\n/**\n * Creates an object composed of the picked source properties.\n */\nexport function pick(input: PlainObject, options: string[]): PlainObject {\n  if (!Array.isArray(options)) {\n    throw new TypeError('options must be an array');\n  }\n\n  return options\n    .filter(d => typeof input[d] !== 'undefined')\n    .reduce((acc: PlainObject, d) => {\n      acc[d] = input[d];\n\n      return acc;\n    }, {});\n}\n\n/**\n * Restrict the values to a certain number of digits.\n */\nexport function restrictValues<T extends LAB | LCH>(\n  input: T,\n  precision: number = PRECISION,\n  forcePrecision = true,\n): T {\n  const output = new Map(Object.entries(input));\n\n  for (const [key, value] of output.entries()) {\n    output.set(key, round(value, precision, forcePrecision));\n  }\n\n  return Object.fromEntries(output) as T;\n}\n\n/**\n * Round decimal numbers.\n */\nexport function round(input: number, precision = 2, forcePrecision = true): number {\n  if (!isNumber(input) || input === 0) {\n    return 0;\n  }\n\n  if (forcePrecision) {\n    const factor = 10 ** precision;\n\n    return Math.round(input * factor) / factor;\n  }\n\n  const absInput = Math.abs(input);\n\n  let digits = Math.abs(Math.ceil(Math.log(absInput) / Math.LN10));\n\n  if (digits === 0) {\n    digits = 2;\n  } else if (digits > precision) {\n    digits = precision;\n  }\n\n  let exponent = precision - (digits < 0 ? 0 : digits);\n\n  if (exponent <= 1 && precision > 1) {\n    exponent = 2;\n  } else if (exponent > precision || exponent === 0) {\n    exponent = precision;\n  }\n\n  const factor = 10 ** exponent;\n\n  return Math.round(input * factor) / factor;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isHex, isNumber } from '~/modules/validators';\n\nimport { Alpha } from '~/types';\n\n/**\n * Add an alpha value to a hex string\n */\nexport function addAlphaToHex(input: string, alpha: Alpha): string {\n  invariant(isHex(input), MESSAGES.inputHex);\n  invariant(isNumber(alpha), MESSAGES.inputNumber);\n\n  if (alpha >= 1) {\n    return removeAlphaFromHex(input);\n  }\n\n  return `${removeAlphaFromHex(input)}${convertAlphaToHex(alpha)}`;\n}\n\n/**\n * Convert an alpha value to a hex value.\n */\nexport function convertAlphaToHex(input: Alpha): string {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n\n  let alpha = input;\n\n  if (input > 1) {\n    alpha /= 100;\n  }\n\n  return Math.round(alpha * 255)\n    .toString(16)\n    .padStart(2, '0');\n}\n\n/**\n * Extract the alpha value from a hex string\n */\nexport function extractAlphaFromHex(input: string): number {\n  invariant(isHex(input), MESSAGES.inputString);\n\n  const alpha = input.substring(7, 9);\n\n  if (!alpha) {\n    return 1;\n  }\n\n  return round(parseInt(alpha, 16) / 255);\n}\n\nexport function hexadecimalToNumber(input: string) {\n  return round(parseInt(input, 16));\n}\n\n/**\n * Remove the alpha value from a hex string\n */\nexport function removeAlphaFromHex(input: string) {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  if (input.length === 5) {\n    return input.substring(0, 4);\n  }\n\n  return input.substring(0, 7);\n}\n","export { default as hex2hsl } from '~/converters/hex2hsl';\nexport { default as hex2oklab } from '~/converters/hex2oklab';\nexport { default as hex2oklch } from '~/converters/hex2oklch';\nexport { default as hex2rgb } from '~/converters/hex2rgb';\n\nexport { default as hsl2hex } from '~/converters/hsl2hex';\nexport { default as hsl2oklab } from '~/converters/hsl2oklab';\nexport { default as hsl2oklch } from '~/converters/hsl2oklch';\nexport { default as hsl2rgb } from '~/converters/hsl2rgb';\n\nexport { default as oklab2hex } from '~/converters/oklab2hex';\nexport { default as oklab2hsl } from '~/converters/oklab2hsl';\nexport { default as oklab2oklch } from '~/converters/oklab2oklch';\nexport { default as oklab2rgb } from '~/converters/oklab2rgb';\n\nexport { default as oklch2hex } from '~/converters/oklch2hex';\nexport { default as oklch2hsl } from '~/converters/oklch2hsl';\nexport { default as oklch2oklab } from '~/converters/oklch2oklab';\nexport { default as oklch2rgb } from '~/converters/oklch2rgb';\n\nexport { default as rgb2hex } from '~/converters/rgb2hex';\nexport { default as rgb2hsl } from '~/converters/rgb2hsl';\nexport { default as rgb2oklab } from '~/converters/rgb2oklab';\nexport { default as rgb2oklch } from '~/converters/rgb2oklch';\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex } from '~/modules/validators';\n\nimport { HEX } from '~/types';\n\nexport default function formatHex(input: string): HEX {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  let color = input.replace('#', '');\n\n  if (color.length === 3 || color.length === 4) {\n    const values = [...color];\n\n    color = '';\n\n    values.forEach(d => {\n      color += `${d}${d}`;\n    });\n  }\n\n  const hex = `#${color}`;\n\n  invariant(isHex(hex), 'invalid hex');\n\n  return hex;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex } from '~/modules/validators';\n\nimport formatHex from '~/format-hex';\nimport { RGB } from '~/types';\n\n/** Convert HEX to RGB */\nexport default function hex2rgb(input: string): RGB {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  const hex = formatHex(input).slice(1);\n\n  return {\n    r: parseInt(hex.charAt(0) + hex.charAt(1), 16),\n    g: parseInt(hex.charAt(2) + hex.charAt(3), 16),\n    b: parseInt(hex.charAt(4) + hex.charAt(5), 16),\n  };\n}\n","import { limit, parseInput } from '~/modules/utils';\n\nimport { ConverterParameters, HSL, RGB } from '~/types';\n\n/** Convert RGB to HSL */\nexport default function rgb2hsl(input: ConverterParameters<RGB>): HSL {\n  const value = parseInput(input, 'rgb');\n\n  const rLimit = limit(value.r, 'rgb', 'r') / 255;\n  const gLimit = limit(value.g, 'rgb', 'g') / 255;\n  const bLimit = limit(value.b, 'rgb', 'b') / 255;\n\n  const min = Math.min(rLimit, gLimit, bLimit);\n  const max = Math.max(rLimit, gLimit, bLimit);\n  const delta = max - min;\n\n  let h = 0;\n  let s;\n  const l = (max + min) / 2;\n  let rate;\n\n  switch (max) {\n    case rLimit:\n      rate = !delta ? 0 : (gLimit - bLimit) / delta;\n      h = 60 * rate;\n      break;\n    case gLimit:\n      rate = (bLimit - rLimit) / delta;\n      h = 60 * rate + 120;\n      break;\n    case bLimit:\n      rate = (rLimit - gLimit) / delta;\n      h = 60 * rate + 240;\n      break;\n    /* c8 ignore next 2 */\n    default:\n      break;\n  }\n\n  if (h < 0) {\n    h = 360 + h;\n  }\n\n  if (min === max) {\n    s = 0;\n  } else {\n    s = l < 0.5 ? delta / (2 * l) : delta / (2 - 2 * l);\n  }\n\n  return {\n    h: Math.abs(+(h % 360).toFixed(2)),\n    s: +(s * 100).toFixed(2),\n    l: +(l * 100).toFixed(2),\n  };\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex } from '~/modules/validators';\n\nimport hex2rgb from '~/converters/hex2rgb';\nimport rgb2hsl from '~/converters/rgb2hsl';\nimport { HSL } from '~/types';\n\n/** Convert HEX to HSL */\nexport default function hex2hsl(input: string): HSL {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  return rgb2hsl(hex2rgb(input));\n}\n","import { LRGB_TO_LMS, LSM_TO_LAB, PRECISION } from '~/modules/constants';\nimport { parseInput, restrictValues } from '~/modules/utils';\n\nimport { ConverterParameters, LAB, RGB } from '~/types';\n\nconst { cbrt, sign } = Math;\n\nfunction rgb2lrgb(input: number) {\n  const abs = Math.abs(input);\n\n  if (abs < 0.04045) {\n    return input / 12.92;\n  }\n\n  return (sign(input) || 1) * ((abs + 0.055) / 1.055) ** 2.4;\n}\n\n/** Convert RGB to oklab */\nexport default function rgb2oklab(input: ConverterParameters<RGB>, precision = PRECISION): LAB {\n  const value = parseInput(input, 'rgb');\n\n  const [lr, lg, lb] = [rgb2lrgb(value.r / 255), rgb2lrgb(value.g / 255), rgb2lrgb(value.b / 255)];\n  const l = cbrt(LRGB_TO_LMS.l[0] * lr + LRGB_TO_LMS.l[1] * lg + LRGB_TO_LMS.l[2] * lb);\n  const m = cbrt(LRGB_TO_LMS.m[0] * lr + LRGB_TO_LMS.m[1] * lg + LRGB_TO_LMS.m[2] * lb);\n  const s = cbrt(LRGB_TO_LMS.s[0] * lr + LRGB_TO_LMS.s[1] * lg + LRGB_TO_LMS.s[2] * lb);\n\n  const lab = {\n    l: LSM_TO_LAB.l[0] * l + LSM_TO_LAB.l[1] * m - LSM_TO_LAB.l[2] * s,\n    a: LSM_TO_LAB.a[0] * l - LSM_TO_LAB.a[1] * m + LSM_TO_LAB.a[2] * s,\n    b: LSM_TO_LAB.b[0] * l + LSM_TO_LAB.b[1] * m - LSM_TO_LAB.b[2] * s,\n  };\n\n  return restrictValues(lab, precision);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex } from '~/modules/validators';\n\nimport hex2rgb from '~/converters/hex2rgb';\nimport rgb2oklab from '~/converters/rgb2oklab';\nimport { LAB } from '~/types';\n\n/** Convert HEX to oklab */\nexport default function hex2oklab(input: string, precision?: number): LAB {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  return rgb2oklab(hex2rgb(input), precision);\n}\n","import { RAD2DEG } from '~/modules/constants';\nimport { parseInput, restrictValues, round } from '~/modules/utils';\n\nimport { ConverterParameters, LAB, LCH } from '~/types';\n\nconst { atan2, sqrt } = Math;\n\n/** Convert oklab to oklch */\nexport default function oklab2oklch(input: ConverterParameters<LAB>, precision?: number): LCH {\n  const { l, a, b } = restrictValues(parseInput(input, 'oklab'));\n\n  const c = sqrt(a ** 2 + b ** 2);\n  let h = (atan2(b, a) * RAD2DEG + 360) % 360;\n\n  if (round(c * 10000) === 0) {\n    h = 0;\n  }\n\n  return restrictValues({ l, c, h }, precision);\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklab2oklch from '~/converters/oklab2oklch';\nimport rgb2oklab from '~/converters/rgb2oklab';\nimport { ConverterParameters, LCH, RGB } from '~/types';\n\n/** Convert RGB to oklch */\nexport default function rgb2oklch(input: ConverterParameters<RGB>, precision?: number): LCH {\n  const value = parseInput(input, 'rgb');\n\n  return oklab2oklch(rgb2oklab(value, precision), precision);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex } from '~/modules/validators';\n\nimport hex2rgb from '~/converters/hex2rgb';\nimport rgb2oklch from '~/converters/rgb2oklch';\nimport { LCH } from '~/types';\n\n/** Convert HEX to oklch */\nexport default function hex2oklch(input: string, precision?: number): LCH {\n  invariant(isHex(input), MESSAGES.inputHex);\n\n  return rgb2oklch(hex2rgb(input), precision);\n}\n","import { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isNumber } from '~/modules/validators';\n\n/**\n * Convert hue to RGB using chroma and median point\n */\nexport default function hue2rgb(point: number, chroma: number, h: number): number {\n  invariant(isNumber(point) && isNumber(chroma) && isNumber(h), 'point, chroma and h are required');\n  let hue = h;\n\n  if (hue < 0) {\n    hue += 1;\n  }\n\n  if (hue > 1) {\n    hue -= 1;\n  }\n\n  if (hue < 1 / 6) {\n    return round(point + (chroma - point) * 6 * hue, 4);\n  }\n\n  if (hue < 1 / 2) {\n    return round(chroma, 4);\n  }\n\n  if (hue < 2 / 3) {\n    return round(point + (chroma - point) * (2 / 3 - hue) * 6, 4);\n  }\n\n  return round(point, 4);\n}\n","import hue2rgb from '~/modules/hue2rgb';\nimport { parseInput, round } from '~/modules/utils';\n\nimport { ConverterParameters, HSL, RGB } from '~/types';\n\n/** Convert HSL to RGB */\nexport default function hsl2rgb(input: ConverterParameters<HSL>): RGB {\n  const value = parseInput(input, 'hsl');\n\n  const h = round(value.h) / 360;\n  const s = round(value.s) / 100;\n  const l = round(value.l) / 100;\n\n  let r;\n  let g;\n  let b;\n\n  let point;\n  let chroma;\n\n  if (s === 0) {\n    r = l;\n    g = l;\n    b = l;\n  } else {\n    chroma = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    point = 2 * l - chroma;\n\n    r = hue2rgb(point, chroma, h + 1 / 3);\n    g = hue2rgb(point, chroma, h);\n    b = hue2rgb(point, chroma, h - 1 / 3);\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n}\n","import { parseInput } from '~/modules/utils';\n\nimport { ConverterParameters, HEX, RGB } from '~/types';\n\n/** Convert RGB to HEX */\nexport default function rgb2hex(input: ConverterParameters<RGB>): HEX {\n  const rgb = parseInput(input, 'rgb');\n\n  return `#${Object.values(rgb)\n    .map(d => `0${Math.floor(d).toString(16)}`.slice(-2))\n    .join('')}`;\n}\n","import { parseInput } from '~/modules/utils';\n\nimport hsl2rgb from '~/converters/hsl2rgb';\nimport rgb2hex from '~/converters/rgb2hex';\nimport { ConverterParameters, HEX, HSL } from '~/types';\n\n/** Convert HSL to HEX */\nexport default function hsl2hex(input: ConverterParameters<HSL>): HEX {\n  const value = parseInput(input, 'hsl');\n\n  return rgb2hex(hsl2rgb(value));\n}\n","import { parseInput } from '~/modules/utils';\n\nimport hsl2rgb from '~/converters/hsl2rgb';\nimport rgb2oklab from '~/converters/rgb2oklab';\nimport { ConverterParameters, HSL, LAB } from '~/types';\n\n/** Convert HSL to oklab */\nexport default function hsl2oklab(input: ConverterParameters<HSL>, precision?: number): LAB {\n  const value = parseInput(input, 'hsl');\n\n  return rgb2oklab(hsl2rgb(value), precision);\n}\n","import { parseInput } from '~/modules/utils';\n\nimport hsl2rgb from '~/converters/hsl2rgb';\nimport rgb2oklch from '~/converters/rgb2oklch';\nimport { ConverterParameters, HSL, LCH } from '~/types';\n\n/** Convert HSL to oklch */\nexport default function hsl2oklch(input: ConverterParameters<HSL>, precision?: number): LCH {\n  const value = parseInput(input, 'hsl');\n\n  return rgb2oklch(hsl2rgb(value), precision);\n}\n","import { LAB_TO_LMS, LSM_TO_RGB } from '~/modules/constants';\nimport { clamp, parseInput, round } from '~/modules/utils';\n\nimport { ConverterParameters, LAB, RGB } from '~/types';\n\nconst { abs } = Math;\n\nfunction lrgb2rgb(input: number) {\n  const absoluteNumber = abs(input);\n  const sign = input < 0 ? -1 : 1;\n\n  if (absoluteNumber > 0.0031308) {\n    return sign * (absoluteNumber ** (1 / 2.4) * 1.055 - 0.055);\n  }\n\n  return input * 12.92;\n}\n\n/** Convert oklab to RGB */\nexport default function oklab2rgb(input: ConverterParameters<LAB>, precision = 0): RGB {\n  const { l: L, a: A, b: B } = parseInput(input, 'oklab');\n\n  const l = (L + LAB_TO_LMS.l[0] * A + LAB_TO_LMS.l[1] * B) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * A + LAB_TO_LMS.m[1] * B) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * A + LAB_TO_LMS.s[1] * B) ** 3;\n\n  const r = 255 * lrgb2rgb(LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s);\n  const g = 255 * lrgb2rgb(LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s);\n  const b = 255 * lrgb2rgb(LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s);\n\n  return {\n    r: clamp(round(r, precision), 0, 255),\n    g: clamp(round(g, precision), 0, 255),\n    b: clamp(round(b, precision), 0, 255),\n  };\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklab2rgb from '~/converters/oklab2rgb';\nimport rgb2hex from '~/converters/rgb2hex';\nimport { ConverterParameters, HEX, LAB } from '~/types';\n\n/** Convert oklab to HEX */\nexport default function oklab2hex(input: ConverterParameters<LAB>): HEX {\n  const value = parseInput(input, 'oklab');\n\n  return rgb2hex(oklab2rgb(value));\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklab2rgb from '~/converters/oklab2rgb';\nimport rgb2hsl from '~/converters/rgb2hsl';\nimport { ConverterParameters, HSL, LAB } from '~/types';\n\n/** Convert oklab to HSL */\nexport default function oklab2hsl(input: ConverterParameters<LAB>): HSL {\n  const value = parseInput(input, 'oklab');\n\n  return rgb2hsl(oklab2rgb(value));\n}\n","/* eslint-disable prefer-const */\nimport { DEG2RAD } from '~/modules/constants';\nimport { parseInput, restrictValues } from '~/modules/utils';\n\nimport { ConverterParameters, LAB, LCH } from '~/types';\n\nconst { sin, cos } = Math;\n\n/** Convert oklch to oklab */\nexport default function oklch2oklab(input: ConverterParameters<LCH>, precision?: number): LAB {\n  /*\n  Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.\n  These formulas were invented by David Dalrymple to obtain maximum contrast without going\n  out of gamut if the parameters are in the range 0-1.\n\n  A saturation multiplier was added by Gregor Aisch\n  */\n  let { l, c, h } = parseInput(input, 'oklch');\n\n  /* c8 ignore next 3 */\n  if (Number.isNaN(h) || h < 0) {\n    h = 0;\n  }\n\n  return restrictValues({ l, a: c * cos(h * DEG2RAD), b: c * sin(h * DEG2RAD) }, precision);\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklab2rgb from '~/converters/oklab2rgb';\nimport oklch2oklab from '~/converters/oklch2oklab';\nimport { ConverterParameters, LCH, RGB } from '~/types';\n\n/** Convert oklch to RGB */\nexport default function oklch2rgb(input: ConverterParameters<LCH>, precision = 0): RGB {\n  const value = parseInput(input, 'oklch');\n\n  return oklab2rgb(oklch2oklab(value), precision);\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklch2rgb from '~/converters/oklch2rgb';\nimport rgb2hex from '~/converters/rgb2hex';\nimport { ConverterParameters, HEX, LCH } from '~/types';\n\n/** Convert oklch to HEX */\nexport default function oklch2hex(input: ConverterParameters<LCH>): HEX {\n  const value = parseInput(input, 'oklch');\n\n  return rgb2hex(oklch2rgb(value));\n}\n","import { parseInput } from '~/modules/utils';\n\nimport oklch2rgb from '~/converters/oklch2rgb';\nimport rgb2hsl from '~/converters/rgb2hsl';\nimport { ConverterParameters, HSL, LCH } from '~/types';\n\n/** Convert oklch to HSL */\nexport default function oklch2hsl(input: ConverterParameters<LCH>): HSL {\n  const value = parseInput(input, 'oklch');\n\n  return rgb2hsl(oklch2rgb(value));\n}\n","import { COLOR_KEYS, MESSAGES } from '~/modules/constants';\nimport { extractAlphaFromHex } from '~/modules/hex-utils';\nimport { invariant } from '~/modules/invariant';\nimport { hasValidMatches, isHex, isString } from '~/modules/validators';\n\nimport hex2rgb from '~/converters/hex2rgb';\nimport { ColorModelKey, PlainObject } from '~/types';\n\nexport type ExtractColorPartsReturn = {\n  alpha?: number;\n  model: ColorModelKey;\n} & PlainObject<number>;\n\n/**\n * Extract the color parts from a CSS color string.\n * Hex colors are not supported.\n */\nexport default function extractColorParts(input: string) {\n  invariant(isString(input), MESSAGES.inputString);\n\n  if (isHex(input)) {\n    const keys = COLOR_KEYS.rgb;\n    const { r, g, b } = hex2rgb(input);\n    const alpha = extractAlphaFromHex(input);\n\n    return {\n      model: 'rgb' as ColorModelKey,\n      [keys[0]]: r,\n      [keys[1]]: g,\n      [keys[2]]: b,\n      alpha: alpha < 1 ? alpha : undefined,\n    } as ExtractColorPartsReturn;\n  }\n\n  const colorRegex =\n    /(?:(rgb|hsl|oklab|oklch)a?\\s*\\(\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)(?:\\s*[ ,/]\\s*([\\d%.-]+))?\\s*\\))/i;\n\n  const matches = colorRegex.exec(input);\n\n  invariant(hasValidMatches(matches), MESSAGES.invalidCSS);\n\n  const model = matches[1] as ColorModelKey;\n  const keys = COLOR_KEYS[model];\n  let alpha = matches[5] ? parseFloat(matches[5]) : 1;\n\n  if (alpha > 1) {\n    alpha /= 100;\n  }\n\n  return {\n    model,\n    [keys[0]]: parseFloat(matches[2]),\n    [keys[1]]: parseFloat(matches[3]),\n    [keys[2]]: parseFloat(matches[4]),\n    alpha: alpha < 1 ? alpha : undefined,\n  } as ExtractColorPartsReturn;\n}\n","import { MESSAGES, PRECISION } from '~/modules/constants';\nimport { CSSColor, cssColors } from '~/modules/css-colors';\nimport { convertAlphaToHex, extractAlphaFromHex, removeAlphaFromHex } from '~/modules/hex-utils';\nimport { invariant } from '~/modules/invariant';\nimport { addAlpha, round } from '~/modules/utils';\nimport { isHex, isNamedColor, isString } from '~/modules/validators';\n\nimport * as converters from '~/converters';\nimport extractColorParts from '~/extract-color-parts';\nimport { ColorTuple, ColorType, HEX, HSL, LAB, LCH, RGB } from '~/types';\n\nexport type ParseCSSReturn<T extends ColorType> = T extends 'hex'\n  ? HEX\n  : T extends 'hsl'\n    ? HSL\n    : T extends 'oklab'\n      ? LAB\n      : T extends 'oklch'\n        ? LCH\n        : T extends 'rgb'\n          ? RGB\n          : never;\n\n/**\n * Parse CSS color\n */\nexport default function parseCSS<T extends ColorType>(\n  input: string,\n  format?: T,\n): ParseCSSReturn<T> {\n  invariant(isString(input), MESSAGES.inputString);\n\n  let result: any;\n\n  const value = isNamedColor(input) ? cssColors[input.toLowerCase() as CSSColor] : input;\n\n  const output = format ?? (isHex(value) ? 'hex' : extractColorParts(value).model);\n\n  const colorParams = (params: Record<string, number>) => Object.values(params) as ColorTuple;\n\n  if (isHex(value)) {\n    const alpha = extractAlphaFromHex(value);\n\n    switch (output) {\n      case 'hsl': {\n        result = addAlpha(converters.hex2hsl(value), alpha);\n        break;\n      }\n      case 'oklab': {\n        result = addAlpha(converters.hex2oklab(value), alpha);\n        break;\n      }\n      case 'oklch': {\n        result = addAlpha(converters.hex2oklch(value), alpha);\n        break;\n      }\n      case 'rgb': {\n        result = addAlpha(converters.hex2rgb(value), alpha);\n        break;\n      }\n      default: {\n        result = `${removeAlphaFromHex(value)}${alpha !== 1 ? convertAlphaToHex(alpha) : ''}`;\n        break;\n      }\n    }\n\n    return result as ParseCSSReturn<T>;\n  }\n\n  switch (output) {\n    case 'hsl': {\n      const { alpha, model, ...color } = extractColorParts(value);\n\n      if (['oklab', 'oklch'].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n\n      result = addAlpha(\n        model === 'hsl' ? color : converters[`${model}2hsl`](colorParams(color)),\n        alpha,\n      );\n\n      break;\n    }\n    case 'oklab': {\n      const { alpha, model, ...color } = extractColorParts(value);\n\n      if (['oklab', 'oklch'].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n\n      result = addAlpha(\n        model === 'oklab' ? color : converters[`${model}2oklab`](colorParams(color)),\n        alpha,\n      );\n\n      break;\n    }\n    case 'oklch': {\n      const { alpha, model, ...color } = extractColorParts(value);\n\n      if (['oklab', 'oklch'].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n\n      result = addAlpha(\n        model === 'oklch' ? color : converters[`${model}2oklch`](colorParams(color)),\n        alpha,\n      );\n      break;\n    }\n    case 'rgb': {\n      const { alpha, model, ...color } = extractColorParts(value);\n\n      if (['oklab', 'oklch'].includes(model) && color.l > 1) {\n        color.l /= 100;\n      }\n\n      result = addAlpha(\n        model === 'rgb' ? color : converters[`${model}2rgb`](colorParams(color)),\n        alpha,\n      );\n      break;\n    }\n\n    case 'hex':\n    default: {\n      const { alpha, model, ...color } = extractColorParts(value);\n      let alphaPrefix = '';\n\n      if (['oklab', 'oklch'].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n\n      if (alpha) {\n        alphaPrefix = convertAlphaToHex(alpha);\n      }\n\n      result = `${converters[`${model}2hex`](colorParams(color))}${alphaPrefix}`;\n\n      break;\n    }\n  }\n\n  return result as ParseCSSReturn<T>;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { addAlphaToHex } from '~/modules/hex-utils';\nimport { invariant } from '~/modules/invariant';\nimport { addAlpha, limit } from '~/modules/utils';\nimport { isHex, isHSL, isLAB, isLCH, isPlainObject, isRGB, isString } from '~/modules/validators';\n\nimport * as converters from '~/converters';\nimport extractColorParts from '~/extract-color-parts';\nimport parseCSS from '~/parse-css';\nimport { Colors, HSL, LAB, LCH, PlainObject, RGB } from '~/types';\n\nexport default function parseColor(color: string | HSL | LAB | LCH | RGB): Colors {\n  invariant(!!color, MESSAGES.input);\n\n  const output: PlainObject = {};\n\n  if (isString(color)) {\n    const { alpha = 1 } = extractColorParts(color);\n    const type = isHex(color) ? 'hex' : extractColorParts(color).model;\n\n    output.hex = addAlphaToHex(parseCSS(color, 'hex'), alpha);\n    output.hsl = addAlpha(parseCSS(color, 'hsl'), alpha);\n    output.oklab = addAlpha(parseCSS(color, 'oklab'), alpha);\n    output.oklch = addAlpha(parseCSS(color, 'oklch'), alpha);\n    output.rgb = addAlpha(parseCSS(color, 'rgb'), alpha);\n\n    output.alpha = alpha;\n    output.type = type;\n  } else if (isPlainObject(color)) {\n    const { alpha = 1 } = color;\n\n    if (isHSL(color)) {\n      output.hsl = {\n        h: limit(color.h, 'hsl', 'h'),\n        s: limit(color.s, 'hsl', 's'),\n        l: limit(color.l, 'hsl', 'l'),\n      };\n      output.rgb = converters.hsl2rgb(output.hsl);\n      output.oklab = converters.hsl2oklab(output.hsl);\n      output.oklch = converters.hsl2oklch(output.hsl);\n      output.type = 'hsl';\n    } else if (isLAB(color)) {\n      output.hsl = converters.oklab2hsl(color);\n      output.oklab = color;\n      output.oklch = converters.oklab2oklch(color);\n      output.rgb = converters.oklab2rgb(color);\n      output.type = 'oklab';\n    } else if (isLCH(color)) {\n      output.hsl = converters.oklch2hsl(color);\n      output.oklab = converters.oklch2oklab(color);\n      output.oklch = color;\n      output.rgb = converters.oklch2rgb(color);\n      output.type = 'oklch';\n    } else if (isRGB(color)) {\n      output.rgb = {\n        r: limit(color.r, 'rgb', 'r'),\n        g: limit(color.g, 'rgb', 'g'),\n        b: limit(color.b, 'rgb', 'b'),\n      };\n      output.hsl = converters.rgb2hsl(output.rgb);\n      output.oklab = converters.rgb2oklab(output.rgb);\n      output.oklch = converters.rgb2oklch(output.rgb);\n      output.type = 'rgb';\n    } else {\n      throw new Error('invalid color');\n    }\n\n    output.hex = addAlphaToHex(converters.hsl2hex(output.hsl), alpha);\n    output.hsl = addAlpha(output.hsl, alpha);\n    output.oklab = addAlpha(output.oklab, alpha);\n    output.oklch = addAlpha(output.oklch, alpha);\n    output.rgb = addAlpha(output.rgb, alpha);\n\n    output.alpha = alpha;\n  } else {\n    throw new Error(MESSAGES.input);\n  }\n\n  return output as Colors;\n}\n","import { MESSAGES, PRECISION } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isString } from '~/modules/validators';\n\nimport parseCSS from '~/parse-css';\n\n/**\n * Get the brightness difference between 2 colors.\n */\nexport default function brightnessDifference(\n  left: string,\n  right: string,\n  precision = PRECISION,\n): number {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n\n  const RGBLeft = parseCSS(left, 'rgb');\n  const RGBRight = parseCSS(right, 'rgb');\n\n  const brightnessLeft = (RGBLeft.r * 299 + RGBLeft.g * 587 + RGBLeft.b * 114) / 1000;\n  const brightnessRight = (RGBRight.r * 299 + RGBRight.g * 587 + RGBRight.b * 114) / 1000;\n\n  return round(Math.abs(brightnessRight - brightnessLeft), precision);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isString } from '~/modules/validators';\n\nimport parseCSS from '~/parse-css';\n\n/**\n * Get the chroma of a color.\n */\nexport default function chroma(input: string): number {\n  invariant(isString(input), MESSAGES.inputString);\n\n  const { r, g, b } = parseCSS(input, 'rgb');\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n\n  return round((max - min) / 255, 4);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isString } from '~/modules/validators';\n\nimport parseCSS from '~/parse-css';\n\n/**\n * Get the difference between 2 colors.\n */\nexport default function colorDifference(left: string, right: string): number {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n\n  const RGBLeft = parseCSS(left, 'rgb');\n  const RGBRight = parseCSS(right, 'rgb');\n\n  return (\n    Math.max(RGBLeft.r, RGBRight.r) -\n    Math.min(RGBLeft.r, RGBRight.r) +\n    (Math.max(RGBLeft.g, RGBRight.g) - Math.min(RGBLeft.g, RGBRight.g)) +\n    (Math.max(RGBLeft.b, RGBRight.b) - Math.min(RGBLeft.b, RGBRight.b))\n  );\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isString } from '~/modules/validators';\n\nimport parseCSS from '~/parse-css';\n\n/**\n * Get the luminance of a color.\n */\nexport default function luminance(input: string): number {\n  invariant(isString(input), MESSAGES.inputString);\n\n  const { r, g, b } = parseCSS(input, 'rgb');\n\n  const rgb = [r / 255, g / 255, b / 255];\n\n  for (let index = 0; index < rgb.length; index++) {\n    if (rgb[index] <= 0.03928) {\n      rgb[index] /= 12.92;\n    } else {\n      rgb[index] = ((rgb[index] + 0.055) / 1.055) ** 2.4;\n    }\n  }\n\n  return round(0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2], 4);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isString } from '~/modules/validators';\n\nimport getLuminance from '~/luminance';\n\n/**\n * Get the color contrast between 2 colors.\n */\nexport default function contrast(left: string, right: string): number {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n\n  const LuminanceLeft = getLuminance(left);\n  const LuminanceRight = getLuminance(right);\n\n  return round(\n    LuminanceLeft >= LuminanceRight\n      ? (LuminanceLeft + 0.05) / (LuminanceRight + 0.05)\n      : (LuminanceRight + 0.05) / (LuminanceLeft + 0.05),\n  );\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isString } from '~/modules/validators';\n\nimport getBrightnessDifference from '~/brightness-difference';\nimport getColorDifference from '~/color-difference';\nimport getContrast from '~/contrast';\nimport { Analysis } from '~/types';\n\n/**\n * Check 2 colors for WCAG compliance.\n */\nexport default function compare(left: string, right: string): Analysis {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n\n  const colorThreshold = 500;\n  const brightnessThreshold = 125;\n\n  const colorDifference = getColorDifference(left, right);\n  const contrast = getContrast(left, right);\n  const brightnessDifference = getBrightnessDifference(left, right);\n\n  const isBright = brightnessDifference >= brightnessThreshold;\n  const hasEnoughDifference = colorDifference >= colorThreshold;\n\n  let compliant = 0;\n\n  if (isBright && hasEnoughDifference) {\n    compliant = 2;\n  } else if (isBright || hasEnoughDifference) {\n    compliant = 1;\n  }\n\n  return {\n    brightnessDifference,\n    colorDifference,\n    compliant,\n    contrast,\n    largeAA: contrast >= 3,\n    largeAAA: contrast >= 4.5,\n    normalAA: contrast >= 4.5,\n    normalAAA: contrast >= 7,\n  };\n}\n","import { MESSAGES, PRECISION } from '~/modules/constants';\nimport { convertAlphaToHex } from '~/modules/hex-utils';\nimport { invariant } from '~/modules/invariant';\nimport { restrictValues, round } from '~/modules/utils';\nimport { isHex, isHSL, isLAB, isLCH, isValidColorModel } from '~/modules/validators';\n\nimport * as converters from '~/converters';\nimport { Alpha, ColorModel, ColorType, HEX, HSL } from '~/types';\n\nexport interface FormatOptions {\n  alpha?: Alpha;\n  /**\n   * The output color type.\n   * @default 'hex'\n   */\n  format?: ColorType;\n  /**\n   * The number of digits of the output.\n   * @default 5\n   */\n  precision?: number;\n  /**\n   * The separator between the values.\n   * oklab and oklch always use space as a separator.\n   * @default ' '\n   */\n  separator?: string;\n}\n\nexport default function formatCSS<T extends ColorModel | HEX>(\n  input: T,\n  options: FormatOptions = {},\n): string {\n  invariant(isHex(input) || isValidColorModel(input), MESSAGES.invalid);\n\n  const { alpha, format = 'hex', precision = PRECISION, separator: baseSeparator = ' ' } = options;\n\n  let value: HSL;\n\n  if (isHex(input)) {\n    value = converters.hex2hsl(input);\n  } else if (isHSL(input)) {\n    value = input;\n  } else if (isLAB(input)) {\n    value = converters.oklab2hsl(input);\n  } else if (isLCH(input)) {\n    value = converters.oklch2hsl(input);\n  } else {\n    value = converters.rgb2hsl(input);\n  }\n\n  const opacity = alpha && alpha !== 1 ? `${round(alpha * 100)}%` : null;\n  let params = [];\n  let separator = baseSeparator;\n\n  switch (format) {\n    case 'hsl': {\n      const { h, s, l } = value;\n\n      params = [h, `${s}%`, `${l}%`];\n      break;\n    }\n    case 'oklab': {\n      separator = ' ';\n      const { l, a, b } = restrictValues(converters.hsl2oklab(value), precision);\n\n      params = [`${round(l * 100, precision)}%`, a, b];\n      break;\n    }\n    case 'oklch': {\n      separator = ' ';\n      const { l, c, h } = restrictValues(converters.hsl2oklch(value), precision);\n\n      params = [`${round(l * 100, precision)}%`, c, h];\n      break;\n    }\n    case 'rgb': {\n      const { r, g, b } = converters.hsl2rgb(value);\n\n      params = [r, g, b];\n      break;\n    }\n    default: {\n      const hex = converters.hsl2hex(value);\n\n      if (alpha && alpha !== 1) {\n        return `${hex}${convertAlphaToHex(alpha)}`;\n      }\n\n      return hex;\n    }\n  }\n\n  return `${format}(${params.join(separator)}${opacity ? ` / ${opacity}` : ''})`;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { clamp } from '~/modules/utils';\nimport { isHex, isNamedColor, isNumber, isString } from '~/modules/validators';\n\nimport extractColorParts from '~/extract-color-parts';\nimport formatCSS from '~/format-css';\nimport parseCSS from '~/parse-css';\nimport { ColorModelKeys, ColorType } from '~/types';\n\n/**\n * Update color properties\n */\nexport default function updater(\n  key: ColorModelKeys<'hsl'>,\n  operator: '+' | '-',\n  format?: ColorType,\n) {\n  return (input: string, amount: number) => {\n    invariant(isString(input), MESSAGES.inputString);\n    invariant(isNumber(amount), MESSAGES.alpha);\n\n    const color = parseCSS(input, 'hsl');\n    const output = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n    return formatCSS(\n      {\n        ...color,\n        [key]: clamp(color[key] + (operator === '+' ? amount : -amount), 0, 100),\n      },\n      { format: format ?? output },\n    );\n  };\n}\n","import updater from '~/modules/updater';\n\nimport { Amount, ColorType } from '~/types';\n\n/**\n * Decrease color lightness\n */\nexport default function darken(input: string, amount: Amount, format?: ColorType): string {\n  return updater('l', '-', format)(input, amount);\n}\n","import updater from '~/modules/updater';\n\nimport { Amount, ColorType } from '~/types';\n\n/**\n * Decrease color saturation\n */\nexport default function desaturate(input: string, amount: Amount, format?: ColorType) {\n  return updater('s', '-', format)(input, amount);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { constrainDegrees } from '~/modules/utils';\nimport { isHex, isNamedColor, isNumber, isString } from '~/modules/validators';\n\nimport extractColorParts from '~/extract-color-parts';\nimport formatCSS from '~/format-css';\nimport parseCSS from '~/parse-css';\nimport { ColorType, Degrees } from '~/types';\n\n/**\n * Change the color hue\n */\nexport default function rotate(input: string, degrees: Degrees, format?: ColorType) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(degrees), 'degrees must be a number');\n\n  const color = parseCSS(input, 'hsl');\n\n  const output = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n  return formatCSS(\n    {\n      ...color,\n      h: constrainDegrees(color.h, degrees),\n    },\n    { format: format ?? output },\n  );\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex, isNamedColor, isString } from '~/modules/validators';\n\nimport extractColorParts from '~/extract-color-parts';\nimport formatCSS from '~/format-css';\nimport parseCSS from '~/parse-css';\nimport rotate from '~/rotate';\nimport { HEX } from '~/types';\n\n/**\n * Invert the color\n */\nexport default function invert(input: string) {\n  invariant(isString(input), MESSAGES.inputString);\n  const format = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n  const hex = parseCSS(input, 'hex');\n\n  return formatCSS(rotate(hex, 180) as HEX, { format });\n}\n","import updater from '~/modules/updater';\n\nimport { Amount, ColorType } from '~/types';\n\n/**\n * Increase color lightness\n */\nexport default function lighten(input: string, amount: Amount, format?: ColorType) {\n  return updater('l', '+', format)(input, amount);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex, isNamedColor, isNumber, isString } from '~/modules/validators';\n\nimport extractColorParts from '~/extract-color-parts';\nimport formatCSS from '~/format-css';\nimport parseCSS from '~/parse-css';\nimport { Alpha, ColorType } from '~/types';\n\n/**\n * Make the color transparent\n */\nexport default function opacify(input: string, alpha: Alpha, format?: ColorType): string {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n  const type = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n  const rgb = parseCSS(input, 'rgb');\n\n  return formatCSS(rgb, { format: format ?? type, alpha });\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { cssColors } from '~/modules/css-colors';\nimport { extractAlphaFromHex } from '~/modules/hex-utils';\nimport { invariant } from '~/modules/invariant';\nimport { isHex, isString } from '~/modules/validators';\n\nimport extractColorParts from '~/extract-color-parts';\n\nexport default function opacity(input: string): number {\n  invariant(isString(input), MESSAGES.inputString);\n\n  if (isHex(input)) {\n    return extractAlphaFromHex(input);\n  } else if (Object.keys(cssColors).includes(input)) {\n    return 1;\n  }\n\n  const { alpha } = extractColorParts(input);\n\n  if (!alpha) {\n    return 1;\n  }\n\n  return alpha;\n}\n","import updater from '~/modules/updater';\n\nimport { ColorType } from '~/types';\n\n/**\n * Increase color saturation\n */\nexport default function saturate(input: string, amount: number, format?: ColorType) {\n  return updater('s', '+', format)(input, amount);\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isString } from '~/modules/validators';\n\nimport hex2rgb from '~/converters/hex2rgb';\nimport parseCSS from '~/parse-css';\n\ninterface Options {\n  /**\n   * The dark color to return if the input is light.\n   * @default '#000000'\n   */\n  darkColor?: string;\n  /**\n   * The light color to return if the input is dark.\n   * @default '#ffffff'\n   */\n  lightColor?: string;\n  /**\n   * The threshold to determine if the color is light or dark.\n   * A number between 0 and 255.\n   * @default 128\n   */\n  threshold?: number;\n}\n\n/**\n * Get the contrasted color for a given hex.\n */\nexport default function textColor(input: string, options: Options = {}): string {\n  const { darkColor = '#000000', lightColor = '#ffffff', threshold = 128 } = options;\n\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(threshold >= 0 && threshold <= 255, MESSAGES.threshold);\n\n  const { r, g, b } = hex2rgb(parseCSS(input, 'hex'));\n  const yiq = (r * 299 + g * 587 + b * 114) / 1000;\n\n  return yiq >= threshold ? darkColor : lightColor;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { clamp, round } from '~/modules/utils';\nimport { isNumber, isString } from '~/modules/validators';\n\nimport formatCSS from '~/format-css';\nimport opacity from '~/opacity';\nimport parseCSS from '~/parse-css';\nimport { Alpha, ColorType } from '~/types';\n\n/**\n * Increase the color transparency.\n */\nexport default function transparentize(input: string, alpha: Alpha, format?: ColorType): string {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n\n  invariant(alpha >= -1 && alpha <= 1, MESSAGES.alpha);\n\n  const oklch = parseCSS(input, 'oklab');\n\n  const value = round(clamp(opacity(input) - alpha, 0, 1));\n\n  return formatCSS(oklch, { format, alpha: value });\n}\n","import { invariant } from '~/modules/invariant';\nimport parseColor from '~/modules/parse-color';\n\nimport brightnessDifference from '~/brightness-difference';\nimport chroma from '~/chroma';\nimport colorDifference from '~/color-difference';\nimport compare from '~/compare';\nimport contrast from '~/contrast';\nimport darken from '~/darken';\nimport desaturate from '~/desaturate';\nimport formatCSS from '~/format-css';\nimport invert from '~/invert';\nimport lighten from '~/lighten';\nimport luminance from '~/luminance';\nimport opacify from '~/opacify';\nimport opacity from '~/opacity';\nimport rotate from '~/rotate';\nimport saturate from '~/saturate';\nimport textColor from '~/text-color';\nimport transparentize from '~/transparentize';\nimport { Alpha, Amount, Analysis, ColorType, Degrees, HEX, HSL, LAB, LCH, RGB } from '~/types';\n\nexport interface Options {\n  /**\n   * The output color type\n   */\n  format?: ColorType;\n}\n\nexport default class Colorizr {\n  public alpha: Alpha;\n  public hex: HEX;\n  public hsl: HSL;\n  public oklab: LAB;\n  public oklch: LCH;\n  public rgb: RGB;\n  public type: ColorType;\n\n  constructor(color: string | HSL | LAB | LCH | RGB, options: Options = {}) {\n    invariant(!!color, 'color is required');\n\n    const { alpha, hex, hsl, oklab, oklch, rgb, type } = parseColor(color);\n\n    this.hex = hex;\n    this.hsl = hsl;\n    this.oklab = oklab;\n    this.oklch = oklch;\n    this.rgb = rgb;\n\n    this.alpha = alpha;\n    this.type = options.format ?? type;\n  }\n\n  /**\n   * Get css string\n   */\n  get css(): string {\n    return this.selectedColor;\n  }\n\n  /**\n   * Get the red value\n   */\n  get red(): number {\n    return Number(this.rgb.r);\n  }\n\n  /**\n   * Get the green value\n   */\n  get green(): number {\n    return Number(this.rgb.g);\n  }\n\n  /**\n   * Get the blue value\n   */\n  get blue(): number {\n    return Number(this.rgb.b);\n  }\n\n  /**\n   * Get the hue value\n   */\n  get hue(): number {\n    return Number(this.hsl.h);\n  }\n\n  /**\n   * Get the saturation value\n   */\n  get saturation(): number {\n    return Number(this.hsl.s);\n  }\n\n  /**\n   * Get the lightness value\n   */\n  get lightness(): number {\n    return Number(this.hsl.l);\n  }\n\n  /**\n   * Get the luminance value\n   */\n  get luminance(): number {\n    return luminance(this.selectedColor);\n  }\n\n  /**\n   * Get the chroma value\n   */\n  get chroma(): number {\n    return chroma(this.selectedColor);\n  }\n\n  get opacity(): number {\n    return opacity(this.selectedColor);\n  }\n\n  /**\n   * Get the contrasted color\n   */\n  get textColor(): string {\n    return textColor(this.selectedColor);\n  }\n\n  private get selectedColor(): string {\n    return formatCSS(this[this.type], { format: this.type, alpha: this.alpha });\n  }\n\n  public brightnessDifference(input: string): number {\n    return brightnessDifference(this.selectedColor, input);\n  }\n\n  public colorDifference(input: string): number {\n    return colorDifference(this.selectedColor, input);\n  }\n\n  /**\n   * Test 2 colors for compliance\n   */\n  public compare(input: string): Analysis {\n    return compare(this.selectedColor, input);\n  }\n\n  public contrast(input: string): number {\n    return contrast(this.selectedColor, input);\n  }\n\n  public format(type: ColorType, precision?: number): string {\n    return formatCSS(this.rgb, {\n      alpha: this.alpha,\n      format: type,\n      precision,\n    });\n  }\n\n  /**\n   * Increase lightness\n   */\n  public lighten(amount: Amount): string {\n    return lighten(this.selectedColor, amount);\n  }\n\n  /**\n   * Decrease lightness\n   */\n  public darken(amount: Amount): string {\n    return darken(this.selectedColor, amount);\n  }\n\n  /**\n   * Increase saturation\n   */\n  public saturate(amount: Amount): string {\n    return saturate(this.selectedColor, amount);\n  }\n\n  /**\n   * Decrease saturation\n   */\n  public desaturate(amount: Amount): string {\n    return desaturate(this.selectedColor, amount);\n  }\n\n  /**\n   * Invert color\n   */\n  public invert(): string {\n    return invert(this.selectedColor);\n  }\n\n  /**\n   * Add opacity to the color.\n   */\n  public opacify(alpha: Alpha = 0.9): string {\n    return opacify(this.selectedColor, alpha, this.type);\n  }\n\n  /**\n   * Rotate color\n   */\n  public rotate(degrees: Degrees): string {\n    return rotate(this.selectedColor, degrees);\n  }\n\n  /**\n   * Make the color more transparent\n   */\n  public transparentize(alpha: Alpha = 0.1): string {\n    return transparentize(this.selectedColor, alpha, this.type);\n  }\n}\n","import formatCSS from '~/format-css';\nimport parseCSS from '~/parse-css';\nimport { ColorType } from '~/types';\n\n/**\n * Convert a color string to another format.\n */\nexport default function convert(input: string, format: ColorType) {\n  const value = parseCSS(input, format);\n\n  return formatCSS(value, { format });\n}\n","import parseCSS from '~/parse-css';\n\nexport default function isValidColor(input: string): boolean {\n  try {\n    parseCSS(input);\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { cssColors } from '~/modules/css-colors';\nimport { invariant } from '~/modules/invariant';\nimport { isString } from '~/modules/validators';\n\nimport parseCSS from '~/parse-css';\n\n/**\n * Get the name of a color.\n * Returns the hex value if the color is not found.\n */\nexport default function name(input: string): string {\n  invariant(isString(input), MESSAGES.inputString);\n\n  const hex = parseCSS(input, 'hex');\n\n  const [color] = Object.entries(cssColors).find(([, value]) => value === hex) || [];\n\n  return color ?? hex;\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex, isNamedColor, isPlainObject, isString } from '~/modules/validators';\n\nimport convert from '~/convert';\nimport hex2hsl from '~/converters/hex2hsl';\nimport hsl2hex from '~/converters/hsl2hex';\nimport extractColorParts from '~/extract-color-parts';\nimport parseCSS from '~/parse-css';\nimport rotate from '~/rotate';\nimport { ColorType, HEX } from '~/types';\n\nexport interface PaletteOptions {\n  format?: ColorType;\n  lightness?: number;\n  saturation?: number;\n  /**\n   * The number of colors to generate\n   * @default 6\n   */\n  size?: number;\n  type?: 'monochromatic';\n}\n\nexport default function palette(input: string, options: PaletteOptions = {}): string[] {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isPlainObject(options), MESSAGES.options);\n\n  const { format, lightness, saturation, size = 6, type } = options;\n  const hsl = parseCSS(input, 'hsl');\n  const output: string[] = [];\n  const colorFormat = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n  switch (type) {\n    case 'monochromatic': {\n      const step = 80 / size;\n\n      for (let index = size; index > 0; index--) {\n        output.push(hsl2hex({ ...hsl, l: step * index }));\n      }\n\n      break;\n    }\n    default: {\n      const step = 360 / size;\n\n      output.push(hsl2hex({ ...hsl, l: lightness ?? hsl.l, s: saturation ?? hsl.s }));\n\n      for (let index = 1; index < size; index++) {\n        const color = rotate(input, hsl.h + step * index, 'hex') as HEX;\n\n        output.push(hsl2hex({ ...hex2hsl(color), l: lightness ?? hsl.l, s: saturation ?? hsl.s }));\n      }\n\n      break;\n    }\n  }\n\n  return output.map(color => convert(color, format ?? colorFormat));\n}\n","import { LAB_TO_LMS, LSM_TO_RGB, MESSAGES, PRECISION, SRGB_TO_P3 } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { round } from '~/modules/utils';\nimport { isNumber, isString } from '~/modules/validators';\n\nimport { oklch2oklab } from '~/converters';\nimport parseCSS from '~/parse-css';\nimport { ColorTuple, LCH } from '~/types';\n\nfunction multiplyMatrix(matrix: number[][], vector: ColorTuple): ColorTuple {\n  return [\n    matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],\n    matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],\n    matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2],\n  ];\n}\n\nfunction isInP3Gamut(color: ColorTuple): boolean {\n  const epsilon = 0.000001;\n\n  return color.every(component => component >= 0 - epsilon && component <= 1 + epsilon);\n}\n\nfunction oklabToLinearSRGB(L: number, a: number, b: number): ColorTuple {\n  const l = (L + LAB_TO_LMS.l[0] * a + LAB_TO_LMS.l[1] * b) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * a + LAB_TO_LMS.m[1] * b) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * a + LAB_TO_LMS.s[1] * b) ** 3;\n\n  return [\n    LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s,\n    LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s,\n    LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s,\n  ];\n}\n\nfunction oklabToLinearP3(L: number, a: number, b: number): ColorTuple {\n  const srgb = oklabToLinearSRGB(L, a, b);\n\n  return multiplyMatrix(SRGB_TO_P3, srgb);\n}\n\n/**\n * Get the maximum chroma for a given lightness and hue in the OkLCH color space\n */\nexport function getOkLCHMaxChroma(input: string | LCH, precision = PRECISION): number {\n  const { l, h } = isString(input) ? parseCSS(input, 'oklch') : input;\n\n  invariant(isNumber(l) && l >= 0 && l <= 1, MESSAGES.lightnessRange);\n  invariant(isNumber(h) && h >= 0 && h <= 360, MESSAGES.hueRange);\n\n  // Binary search parameters\n  const epsilon = 0.000001;\n  let low = 0;\n  let high = 0.5; // Increased max theoretical chroma\n\n  while (high - low > epsilon) {\n    const mid = (low + high) / 2;\n    const { l: L, a, b } = oklch2oklab({ l, c: mid, h }, 16);\n\n    const p3Color = oklabToLinearP3(L, a, b);\n\n    if (isInP3Gamut(p3Color)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n\n  return round(low, precision);\n}\n\n/**\n * Get a OkLCH color in the P3 color space.\n */\nexport function getP3Color(input: string | LCH): string {\n  const lch = isString(input) ? parseCSS(input, 'oklch') : input;\n\n  return `oklch(${lch.l} ${getOkLCHMaxChroma(lch)} ${lch.h})`;\n}\n","import formatCSS from '~/format-css';\nimport { ColorType } from '~/types';\n\n/**\n * Generate a random color.\n */\nexport default function random(type: ColorType = 'hex'): string {\n  const hsl = {\n    h: Math.floor(Math.random() * 360) + 1,\n    s: Math.floor(Math.random() * 90) + 10,\n    l: Math.floor(Math.random() * 80) + 10,\n  };\n\n  return formatCSS(hsl, { format: type });\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { isHex, isNamedColor, isString } from '~/modules/validators';\n\nimport convert from '~/convert';\nimport extractColorParts from '~/extract-color-parts';\nimport rotate from '~/rotate';\nimport { ColorType } from '~/types';\n\nexport type Scheme =\n  | 'analogous'\n  | 'complementary'\n  | 'rectangle'\n  | 'split'\n  | 'split-complementary'\n  | 'square'\n  | 'tetradic'\n  | 'triadic';\n\nexport interface SchemeOptions {\n  format?: ColorType;\n  /**\n   * The type of scheme to generate.\n   * @default 'complementary'\n   */\n  type?: Scheme;\n}\n\n/**\n * Get the scheme for a color.\n */\nexport default function scheme(input: string, typeOrOptions?: Scheme | SchemeOptions): string[] {\n  invariant(isString(input), MESSAGES.inputString);\n  const { format, type = 'complementary' } = isString(typeOrOptions)\n    ? { type: typeOrOptions }\n    : (typeOrOptions ?? {});\n\n  const output = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n  const colors: string[] = [];\n\n  switch (type) {\n    case 'analogous': {\n      colors.push(rotate(input, -30), input, rotate(input, 30));\n      break;\n    }\n    case 'complementary': {\n      colors.push(input, rotate(input, 180));\n      break;\n    }\n\n    case 'split':\n    case 'split-complementary': {\n      colors.push(input, rotate(input, 150), rotate(input, 210));\n      break;\n    }\n    case 'triadic': {\n      colors.push(input, rotate(input, 120), rotate(input, 240));\n      break;\n    }\n\n    case 'tetradic':\n    case 'rectangle': {\n      colors.push(input, rotate(input, 60), rotate(input, 180), rotate(input, 240));\n      break;\n    }\n    case 'square': {\n      colors.push(input, rotate(input, 90), rotate(input, 180), rotate(input, 270));\n      break;\n    }\n    default: {\n      throw new TypeError('invalid type');\n    }\n  }\n\n  return colors.map(color => convert(color, format ?? output));\n}\n","import { MESSAGES } from '~/modules/constants';\nimport { invariant } from '~/modules/invariant';\nimport { clamp } from '~/modules/utils';\nimport { isHex, isNamedColor, isString } from '~/modules/validators';\n\nimport convert from '~/convert';\nimport { oklch2hex } from '~/converters';\nimport oklch2rgb from '~/converters/oklch2rgb';\nimport rgb2hex from '~/converters/rgb2hex';\nimport extractColorParts from '~/extract-color-parts';\nimport parseCSS from '~/parse-css';\nimport { ColorType, HEX, LCH } from '~/types';\n\ntype ColorTokens = 50 | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;\n\ntype Swatch = {\n  [key in ColorTokens]: string;\n};\n\nexport interface SwatchOptions {\n  format?: ColorType;\n  /**\n   * Generate a monochromatic swatch.\n   * @default false\n   */\n  monochromatic?: boolean;\n  /**\n   * The scale of the swatch.\n   * Linear scale will have equal distance between each shade.\n   * @default 'dynamic'\n   */\n  scale?: 'dynamic' | 'linear' | 'monochromatic';\n}\n\nconst MIN_LIGHTNESS = 21;\nconst MAX_LIGHTNESS = 97;\n\n/**\n * Generate a shade of a color based its lightness tuning factor\n */\nfunction shadeColorDynamic(input: LCH, lightnessTuningFactor: number, chromaTuningFactor = 0): HEX {\n  if (lightnessTuningFactor === 0) {\n    return rgb2hex(oklch2rgb({ ...input, l: input.l / 100 }));\n  }\n\n  // Convert back to RGB and make sure it's within the sRGB gamut\n  return shadeColor(input, input.l + lightnessTuningFactor, chromaTuningFactor);\n}\n\n/**\n * Generate a shade of a color based its lightness tuning factor\n */\nfunction shadeColor(input: LCH, lightness: number, chromaTuningFactor = 0): HEX {\n  const { c, h } = input;\n\n  // Convert back to RGB and make sure it's within the sRGB gamut\n  return oklch2hex({ l: lightness / 100, c: clamp(c + chromaTuningFactor, 0, 0.4), h });\n}\n\n/**\n * Generate a palette of shades of a color\n */\nexport default function swatch(input: string, options: SwatchOptions = {}): Swatch {\n  invariant(isString(input), MESSAGES.inputString);\n  const { format, monochromatic = false, scale = 'dynamic' } = options;\n\n  const lch = parseCSS(input, 'oklch');\n\n  lch.l = 50;\n\n  const colorFormat = isHex(input) || isNamedColor(input) ? 'hex' : extractColorParts(input).model;\n\n  const currentLightness = lch.l;\n  const safeMaxLightness = currentLightness >= 88.5 ? 99.5 : MAX_LIGHTNESS;\n  const safeMinLightness = currentLightness <= 33 ? 0 : MIN_LIGHTNESS;\n  const lightBase = (safeMaxLightness - currentLightness) / 5;\n  const darkBase = (-1 * (currentLightness - safeMinLightness)) / 8;\n\n  const output: Swatch =\n    scale === 'linear'\n      ? {\n          50: shadeColor(lch, 95, monochromatic ? 0 : -0.00375),\n          100: shadeColor(lch, 90, monochromatic ? 0 : -0.00375),\n          200: shadeColor(lch, 80, monochromatic ? 0 : -0.00375),\n          300: shadeColor(lch, 70, monochromatic ? 0 : -0.00375),\n          400: shadeColor(lch, 60, monochromatic ? 0 : -0.00375),\n          500: shadeColor(lch, 50, 0),\n          600: shadeColor(lch, 40, monochromatic ? 0 : 0.025),\n          700: shadeColor(lch, 30, monochromatic ? 0 : 0.05),\n          800: shadeColor(lch, 20, monochromatic ? 0 : 0.075),\n          900: shadeColor(lch, 10, monochromatic ? 0 : 0.1),\n        }\n      : {\n          50: shadeColorDynamic(lch, 5 * lightBase, monochromatic ? 0 : -0.00375),\n          100: shadeColorDynamic(lch, 4 * lightBase, monochromatic ? 0 : -0.00375),\n          200: shadeColorDynamic(lch, 3 * lightBase, monochromatic ? 0 : -0.00375),\n          300: shadeColorDynamic(lch, 2 * lightBase, monochromatic ? 0 : -0.00375),\n          400: shadeColorDynamic(lch, lightBase, monochromatic ? 0 : -0.00375),\n          500: shadeColorDynamic(lch, 0),\n          600: shadeColorDynamic(lch, 1.6 * darkBase, monochromatic ? 0 : 0.025),\n          700: shadeColorDynamic(lch, 1.875 * 2 * darkBase, monochromatic ? 0 : 0.05),\n          800: shadeColorDynamic(lch, 3 * 2 * darkBase, monochromatic ? 0 : 0.075),\n          900: shadeColorDynamic(lch, 4 * 2 * darkBase, monochromatic ? 0 : 0.1),\n        };\n\n  return Object.entries(output).reduce((acc, [key, value]) => {\n    return {\n      ...acc,\n      [key]: convert(value, format ?? colorFormat),\n    };\n  }, {} as Swatch);\n}\n","import Colorizr from '~/colorizr';\n\nexport { default as brightnessDifference } from '~/brightness-difference';\nexport { default as chroma } from '~/chroma';\nexport { default as colorDifference } from '~/color-difference';\nexport { default as compare } from '~/compare';\nexport { default as contrast } from '~/contrast';\nexport { default as convert } from '~/convert';\nexport { default as darken } from '~/darken';\nexport { default as desaturate } from '~/desaturate';\nexport { default as extractColorParts } from '~/extract-color-parts';\nexport { default as formatCSS } from '~/format-css';\nexport { default as formatHex } from '~/format-hex';\nexport { default as isValidColor } from '~/is-valid-color';\nexport { default as lighten } from '~/lighten';\nexport { default as luminance } from '~/luminance';\nexport { default as name } from '~/name';\nexport { default as palette } from '~/palette';\nexport { default as opacify } from '~/opacify';\nexport { default as opacity } from '~/opacity';\nexport { getOkLCHMaxChroma, getP3Color } from '~/p3';\nexport { default as parseCSS } from '~/parse-css';\nexport { default as random } from '~/random';\nexport { default as rotate } from '~/rotate';\nexport { default as saturate } from '~/saturate';\nexport { default as scheme } from '~/scheme';\nexport { default as swatch } from '~/swatch';\nexport { default as textColor } from '~/text-color';\nexport { default as transparentize } from '~/transparentize';\n\nexport * from '~/converters';\nexport * from '~/types';\nexport * from '~/modules/hex-utils';\nexport { isHex, isHSL, isLAB, isLCH, isRGB } from '~/modules/validators';\n\n// eslint-disable-next-line unicorn/prefer-export-from\nexport default Colorizr;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}